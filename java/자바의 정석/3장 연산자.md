# 1. 연산자

- 연산을 수행하는 기호
- 자바에서는 사칙연산을 비롯해서 다양한 연산자들을 제공

## 1.1 연산자와 피연산자

- 연산자
    - 연산을 수행하는 기호
    - +, -, *, / 등
- 피연산자
    - 연산자의 작업 대상
    - 변수, 상수, 리터럴, 수식

## 1.2 식과 대입연산자

- 식, expression
    - 연산자와 피연산자를 조합하여 계산하고자하는 바를 표현한 것
- 식을 평가한다, evaluation
    - 식을 계산하여 결과를 얻는 것
    - 하나의 식을 평가하면, 단 하나의 결과만 나옴
- 식의 끝에 ‘;’을 붇여서 문장으로 만듬
- 식이 평가된 후 나온 결과는 대입 연산자를 사용해서 값을 저장할 수 있는 공간에 저장

## 1.3 연산자의 종류

- 산술 연산자
    - 사칙 연산과 나머지 연산
- 비교 연산자
    - 크고 작음과 같고 다름을 비교
- 논리 연산자
    - AND와 OR으로 조건을 연결
- 대입 연산자
    - 우변의 값을 좌변에 저장
- 기타
    - 형변환 연산자, 삼항 연산자, instanceof 연산자

### 피연산자의 개수에 의한 분류

- 단항 : 피연산자 1개
- 이항 : 피연산자 2개
- 삼항 : 피연산자 3개

## 1.4 연산자의 우선순위와 결합규칙

- 연산자가 둘 이상인 경우, 우선순위에 의해서 연산순서가 결정

### 연산자 우선순위

- 산술 > 비교 > 논리 > 대입
- 단항 > 이항 > 삼항

### 연산자 결합규칙

- 같은 우선순위의 연산자들이 여러 개 있는 경우 처리하는 규칙
- 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽

## 1.5 산술 변환

- 이항 연산자는 두 피연산자의 타입이 일치해야 연산이 가능
    - 다르다면 형병환 연산자로 타입을 일치시켜야 한다
    - 대부분의 경우 더 큰 타입으로 일치
- 타입의 일치를 위해 자동 형변환되는 것을 ‘산술 변환’ 또는 ‘일반 산술 변환’이라 함
- 연산결과의 타입은 피연산자의 타입과 일치

### 산술변환 규칙

1. 두 피연산자의 타입을 같게 일치시킴(보다 큰 타입으로 일치)
2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환

# 2. 단항 연산자

## 2.1 증감 연산자 ++, --

- 피연산자에 저장된 값을 1 증가 또는 감소
- 피연산자의 양쪽 위치에 모두 가능
    - 왼쪽은 전위형
    - 뒤쪽은 후위형
- 증감연산자가 수식이나 메서드 호출에 포함된 경우 전위형일 때와 후위형일 때의 결과가 다름
    - 전위형: 값이 참조되기 전에 증가
    - 후위형: 값이 참조된 후에 증가
- 식에 두 번 이상 포함된 변수에 증감연산자를 사용하는 것은 피해야 함

## 2.2 부호 연산자 +, -

- `-` 연산자는 피연산자의 부호를 반대로 변경
- `+` 연산자는 하는일이 없음

# 3. 산술 연산자

- 사칙 연산자(+, -, *, /)와 나머지 연산자(%)가 있다

## 3.1 사칙 연산자 +, -, *, /

- 곱셈, 나눗셈이 덧셈 뺄샘보다 먼저 계산
- 피연산자가 정수형인 경우, 나누는 수로 0을 사용할 수 없음
- 정수형끼리 나누면 소수점은 절삭됨. 반올림 발생하지 않음
- 올바른 값을 얻으려면 한쪽 타입을 변경
- int보다 작은 타입은 계산시에 int로 타입이 변경됨
- 사칙연산의 피연산자로 문자도 가능. 해당 문자의 유니코드로 바뀌어 저장되므로 정수간의 연산과 동일
- 상수 또는 리터럴 간의 연산은 실행 과정동안 값이 변하지 않음
    - 컴파일 시에 컴파일러가 계산해서 그 결과로 대체
    - 수식에 변수가 들어가면 컴파일러가 미리 계산을 할수 없음
    - 하루를 초로 계산할 때 `60*60*24`로 코딩해도 컴파일러가 `86400`으로 변환

## 3.2 나머지 연산자 %

- 왼쪽의 피연산자를 오른쪽 피연산자로 나누고 난 나머지 값을 결과로 반환
- 나누는 수로 `0` 사용 불가
- 음수로도 나눌 수 있지만 부호는 무시된다

# 4. 비교 연산자

- 두 피연산자를 비교하는데 사용
- 연산 결과는 `true`와 `false`
- 타입이 다를 경우 자료형의 크기가 큰쪽으로 자동 형변환 됨

## 4.1 대소비교 연산자 <, >, ≤, ≥

- 두 피연산자의 값의 크기를 비교
- 참이면 `true`, 거짓이면 `false`
- boolean과 참조형에 사용 불가

## 4.2 등가비교 연산자 ==, ≠

- 값이 같은지 또는 다른지 비교
- 기본형과 참조형 모두에 사용 가능
    - 기본형은 값을 비교
    - 참조형은 주소값 비교
- 기본형과 참조형은 서로 형변환이 불가능하기 때문에 서로 등가비교 불가
- 실수형은 근사값으로 저장되기 때문에 오차가 발생해서 잘못된 계산 결과가 나올 수 있음

### 문자열의 비교

- 문자열은 == 대신 equals()라는 메서드를 사용

# 5. 논리 연산자

- 두 개의 조건이 결합된 경우 사용하는 것이 논리 연산자
- 둘 이상의 조건을 ‘그리고(AND)’나 ‘또는(OR)’으로 연결하여 하나의 식으로 표현

## 5.1 논리 연산자 &&, ||, !

- `&&`: 그리고, 두 피연산자 모두 `true` 경우에만 `true`
- `||`: 또는, 두 피연산자 중 하나라도 `true`일 경우 `true`
- `!`: 산술 논리 연산, 피연산자가 `true`이면 `false`를, `false`이면 `true`를 반환. 즉 `true`와 `false`를 반대로 바꾸는 것

### 효율적인 연산

- 논리 연산자의 특징은 효율적인 연산을 함
- OR연산의 경우 둘중 하나만 `true`여도 되기 때문에 좌측이 `true`이면 우측 피연산자의 값은 평가하지 않음
- AND 연산도 좌측이 `false`라면 우측은 평가하지 않음
- 피연산자의 위치에 의해 연산 속도가 달라질 수 있음

## 5.2 비트 연산자 &, |, ^, ~, <<, >>

- 피연산자를 비트단위로 논리 연산 수행
- 피연산자로 실수는 허용하지 않음, 정수와 문자만 허용
- `|`(OR연산자): 피연산자 중 한 쪽의 값이 1이면, 1을 결과로 얻음. 그외에는 0
- `&`(AND연산자): 피연산자 양 쪽이 모두 1이어야만 1을 반완. 그 외에는 0
- `^`(XOR연산자): 피연산자의 값이 서로 다를 때만 1을 반환. 그 외에는 0
- 비트연산에도 피연산자의 타입을 일치시키는 산술 변환이 일어날 수 있다

### 비트 전환 연산자 ~

- 피연산자를 2진수로 표현했을 때, 0은 1로, 1은 0으로 바꿈
- 피연산자의 1의 보수를 얻을 수 있음

### 쉬프트 연산자 <<, >>

- 피연산자의 각 자리를 오른쪽(>>), 왼쪽(<<)으로 이동(shift)
    - `8 << 2` → 10진수 8의 2진수를 왼쪽으로 2자리 이동
- 자리이동으로 저장범위를 벗어난 값들은 버려지고 빈자리는 0으로 채워짐
- >> 연산자는 오른쪽으로 이동시키기 때문에 부호있는 정수는 부호를 유지하기 위해 음수인 경우 빈자리를 1로 채움
- 좌측 피연산자는 int보다 작을경우 산술변환 적용
- 우측 피연산자는 산술변환이 적용되지 않음
- 곱셈 나눗셈보다 <<나 >>를 쓰면 속도가 더 빠름

# 6. 그 외의 연산자

## 6.1 조건 연산자 ? :

- 조건식, 식1, 식2 모두 세 개의 피연산자를 필요로 함
    - `조건식 ? 식1 : 식2`
- 조건식이 `true`이면 `식1`이 `false`이면 `식2`가 연산의 결과가 됨
- 식1과 식2의 타입이 다른 경우 이항 연산자처럼 산술 변환이 발생

## 6.2 대입 연산자 =, op=

- 변수와 같은 저장공간에 값 또는 수식의 연산결과를 저장하는데 사용
- 오른쪽(rvalue) 피연산자의 값을 왼쪽(lvalue) 피연산자에 저장
- 연산자들 중에서 제일 낮은 우선순위

### 복합 대입 연산자

- 다른 연산자(op)와 결합되어 `op=`와 같은 방식으로 사용
    - `i = i + 3` == `i += 3`는 같은 표현식
- `op`와 `=` 사이에 공백이 있으면 안됨