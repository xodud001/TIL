# 함수형 인터페이스
* 함수형 인터페이스는 추상 메소드를 하나만 가지고 있는 인터페이스이다.
* 추상 메소드가 2개 이상 있으면 안됨!
* 함수형 인터페이스를 만들기 위해서는 @FunctionInterface 어노테이션을 인터페이스 달아주면 된다. 자바에서 지원되는 기능이라 import 없음
    * 해당 어노테이션을 달고 추상 메소드를 2개 이상 만들면 컴파일 에러 발생

interface에서는 abstract 생략가능. `void run();`이라고 선언된 메소드는 앞에 `abstract`를 포함하고 있음.

자바 8에서 interface에 static, default 키워드가 붙은 메소드가 있어도 **추상 메소드만 1개이면 함수형 인터페이스이다.**

```java
@FunctionalInterface
public interface RunSomething {

    void doIt();
}
```


## 익명클래스로 사용
위의 함수형 인터페이스를 아래와 같이 익명클래스를 생성해서 사용할 수 있다.
```java
RunSomething runSomething = new RunSomething() {
    @Override
    public void doIt() {
        System.out.println("test");
    }
};

runSomething.doIt();
```

## 람다로 사용
위의 함수형 인터페이스를 아래와 같이 람다를 이용해서 구현할 수 있다.
```java
RunSomething runSomething = () -> System.out.println("test");

runSomething.doIt();
```
람다는 함수같이 보이지만 java에서는 이 또한 객체이다.

# 람다
* 함수형 인터페이스를 익명 클래스로 사용 할 때 코드를 줄여서 표현 할 수 있는 식
* `(...인자) -> { 바디 }` 로 표현되는 식
* 바디가 1줄이면 `{}` 생략 가능
* 인자에 타입은 타입추론을 이용해서 생략 가능
* 람다에서 외부 변수를 참조 할 때는 final or effectively final 만 참조 가능
    * effectively final : final 키워드가 없는 외부에 선언된 변수가 람다에서 참조될 때 final로 바뀌는 것.
* 람다는 변수의 scope이 감싸고 잇는 메소드와 같음
    + 외부에 i라는 변수가 있고 파라미터나 내부에서 i라는 변수가 선언되서 사용 될 때 외부의 i라는 변수에 shadowing이 안됨
        + shadowing : 내부의 변수가 외부의 변수를 가리는 것

# 메소드 레퍼런스
람다가 하는 일이 기존 메소드 또는 생성자를 호출하는 용도라면, 메소드 레퍼런스를 사용해서 매우 간결하게 표현할 수 있음

## 메소드 참조 방법
* 스태틱 메소드 참조 = `타입::스태틱 메소드`
* 특정 객체의 인스턴스 메소드 참조 = `객체 레퍼런스::인스턴스 메소드`
* 임의 객체의 인스턴스 메소드 참조 = `타입::인스턴스 메소드`
* 생성자 참조 = `타입::new`

# 인터페이스 기본 메소드와 스태틱 메소드
* 기본 메소드
    + 인터페이스에 메소드 선언이 아니라 구현체를 제공하는 방법
    + 해당 인터페이스의 구현체들에 컴파일 에러를 내지않고 새 기능 추가 할 수 있음
    + 구현체는 해당 기능을 모르기 때문에 주의
    + Object가 제공하는 기능은 기본 메소드로 제공 불가
* 스태틱 메소드
    + 인터페이스에 스태틱 메소드를 제공할 수 있음