# 5장 안정 해시 설계
- 수평적 규모 확장성을 달성하기 위해서는 요청 또는 데이터를 서버에 균등하게 나누는 것이 중요
- 이때 안정 해시를 보편적으로 사용

## 해시 키 재배치 문제

- N개의 캐시 서버가 있고 부하를 균등하게 나누기 위해 아래 해시 삼수를 사용
    + ServerIndex = hash(key) % N(서버 대수)
    + key0 키의 경우 해시가 18358617일때 % 4를 하면 1의 ServerIndex가 나온다
- 위 경우에서 서버의 풀에 변화가 생기면 문제가 발생
- 1번 서버로 가던 요청이 1번 서버의 장애로 서버 풀이 변경되면 해시 재배치가 일어나는데 이때 대규모 캐시 미스가 발생

## 안정 해시
- 해시 테이블 크기가 조정될 때 평균적으로 오직 k/n개의 키만 재배치하는 해시 기술
    + k = 키의 개수
    + n = 슬롯의 개수
    + 전통적인 해시 테이블은 슬롯의 수가 변경되면 대부분 키를 재배치 함

### 해시 공간과 해시 링
- SHA-1로 예를 들때 해시 공간 범위는 0부터 2^160 - 1까지라 알려져 있음
- 따라서 x0은 0, xn은 2^160 - 1이다
- 이 해시 공간을 링으로 만들면 x0과 xn이 맞닿은 모양이 된다

### 해시 서버
- 이때 해시 함수를 사용해서 서버의 정보로 해시 링의 어떤 위치에 대응 시킬 수 있음
    + 해시 슬롯에 서버 정보로 해시 함수를 돌려 저장한다는 뜻

### 해시 키
- 이때 키에 해시 함수를 돌려 나머지 연산을 하지 않고 해시 키도 슬롯에 배치를 시킴

### 서버 조회
- 이때 저장된 해시 키는 시계 방향으로 링을 탐색하면서 만나는 첫 번째 서버를 조회함

### 서버 추가 및 제거
- 위 셜명한 내용에 따르면 서버를 추가 또는 제거하면 키 가운데 일부분만 재배치하면 됨
- 나머지 키에는 영향이 없음

## 기본 구현법의 두 가지 문제
- 서버가 추가되거나 삭제되는 상황을 감안하면 파티션의 크기를 균등하게 유지하는게 불가능
- 키의 균등 분포를 달성하기가 어려움
- 해당 문제를 해결하기 위해 제안된 기법이 가상 노드 또는 복제 기법

### 가상 노드
- 실제 노드 또는 서버를 가리키는 노드로서 하나의 서버는 링 위에 여러 개의 가상 노드를 가질 수 있다
- 가상 노드 개수를 늘리면 키의 분포는 점점 균등해 짐

# 6장 키-값 저장소 설계
- 키-값 저장소는 키-값 데이터베이스라고도 불리는 비 관계형 데이터베이스다
- 이 저장소에 저장되는 값은 고유 식별자를 키로 가져야 함
- 키와 값 사이의 연결 관계를 "키-값"쌍이라고 지칭
    + 키는 유일해야만 함
    + 값은 해당 키를 통해서만 접근 가능
- 키는 일반 텍스트일 수도 있고 해시 값 등이 될 수 있음
- 갑승ㄴ 문자열이나, 리스트, 객체 등일 수 있다
- 키-값 저장소로 널리 알려진것은 AWS 다이나모, memcached, Redis 등이 있다

## 문제 이해 및 설계 범위 확정
- 완벽한 설계란 없음
- 읽기, 쓰기, 메모리 사용량 사이에서 균형을 찾아 데이터 일관성과 가용성 사이에서 타협적 결정을 내리면 됨

## 단일 서버 키-값 저장소
- 가장 직관적인 방법은 키-값 쌍 전부를 메모리에 해시 테이블로 저장
    + 빠른 속도를 보장하긴 하지만 모든 데이터를 메모리에 두는 것이 불가능할 수 있음
    + 해결책으로는 데이터 압축, 자주 사용되는 데이터만 메모리에 적재 등이 있다

## 분산 키-값 저장소
- 분산 시스템을 설계할 때는 CAP 정리를 이해해야 함

```
CAP 정리
- 데이터 일관성(consistency), 가용성(availability), 파티션 감내(partition tolerance)라는 세 가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다는 정리
```
- 데이터 일관성: 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속하든 언제나 같은 데이터를 받아야 한다
- 가용성: 분산 시스템에 접속하는 클라이언트는 일부 노드에 장애가 발생하더라도 항상 응답을 받을 수 있어야 한다
- 파티션 감내: 파티션은 두 노드 사이에 통신 장애가 발생하였음을 의미. 파티션 감내는 네트워크에 파티션이 생기더라도 시스템은 계속 동작 해야함
- 위 요구사항 중 어떤 두 가지를 만족하면 하나는 반드시 희생해야 함
    + CP 시스템: 일관성과 파티션 감내를 지원. 가용성 희생
    + AP 시스템: 가용성과 파티션 감내를 지원. 데이터 일관성 희생
    + CA 시스템: 일관성과 가용성 지원. 파티션 감내 희생. 하지만 통상 네트워크 장애는 피할 수 없는 일로 여겨지므로, 분산 시스템은 반드시 파티션 문제를 감내할 수 있도록 설계
- 은행 같은 곳은 데이터 일관성이 중요하기 때문에 CP 시스템을 사용할것이고 뉴스 같은 컨텐츠를 제공하는 곳은 가용성이 중요하기 때문에 AP 시스템을 사용

## 시스템 컴포넌트
- 키-값 저장소 구현에 사용될 핵심 컴포넌트들 및 기술

### 데이터 파티션
- 대규모 시스템의 경우 데이터를 나눠서 저장해야하는데 가장 단순한 방법은 작은 파티션들로 분할한 다음 여러 대 서버에 저장하는 것
- 파티션 단위로 나눌 때는 아래 두 가지 문제가 중요
    + 데이터를 여러 서버에 고르게 분산 가능한가
    + 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가
- 5장에서 다룬 안정 해시는 위 문제를 푸는데 적합
    + 규모 확장 자동화: 시스템 부하에 따라서 서버가 자동으로 추가되거나 삭제되도록 가능
    + 다양성: 각 서버의 용량에 맞게 가상 노드 수를 조정 할 수 있음

### 데이터 다중화
- 높은 가용성과 안정성을 확보하기 위해서 데이터를 N개 서버에 비동기적으로 다중화 할 필요가 있음
- N개 서버는 해시링 위에서 시계 방향으로 순회하며 만나는 N개의 서버에 데이터 사본을 저장
    + 가상 노드를 사용하면 선택한 N개의 노드가 대응될 실제 물리 서버의 개수가 N보다 작아질 수 있음
    + 그래서 노드 선택할 때 중복된 물리 서버를 선택하지 않도록 처리

### 데이터 일관성
- 여러 노드에 다중화된 데이터는 적절히 동기화가 되어야 함
- 정족수 합의 프로토콜을 사용하면 읽기/쓰기 연산 모두에 일관성을 보장할 수 있음
    + N = 사본 개수
    + W = 쓰기 연산에 대한 정족수. 쓰기 연산이 성공한 것으로 간주되려면 적어도 W개의 서버로부터 쓰기 연산이 성공했다는 응답을 받아야 함
    + R = 읽기 연산에 대한 정족수. 읽기 연산이 성공한 것으로 간주되려면 적어도 R개의 서버로부터 응답을 받아야 함
    + R=1, W=N: 빠른 읽기 연산에 최적화
    + W=1, R=N: 빠른 쓰기 연산에 최적화
    + W+R > N: 강한 일관성이 보장됨
    + W+R <= N: 강한 일관성이 보장되지 않음

### 일관성 모델
- 일관성 모델은 데이터 일관성의 수준을 결정
- 강한 일관성: 모든 읽기 연산은 가장 최근에 갱신된 결과를 반환
- 약한 일관성: 가장 최근에 갱신된 결과를 반환하지 못할 수 있음
- 최종 일관성: 갱신 결과가 결국에는 모든 사본에 반영되는 모델
    + 데이터에 버전 정보를 넣어 클라이언트에서 일관성이 깨진 데이터를 읽지 않도록 함

### 비 일관성 해소 기법: 데이터 버저닝
- 데이터를 다중화하면 사본 간 일관성이 깨질 가능성이 높음
- 버저닝과 벡터 시계로 문제를 해소할 수 있음
    + 버저닝: 데이터를 변경할 때마다 해당 데이터의 새로운 버전을 생성. 각 버전의 데이터는 변경 불가능
    + 벡터 시계: 데이터 버저닝 과정에서 버전간 충돌이 발생했을 때 사용되는 기술로 [서버, 버전]의 순서쌍을 데이터에 매단 것

### 장애 처리
- 대규모 시스템에서 장애는 아주 흔한 일이기 때문에 장애를 어떻게 처리할 것인지는 굉장히 중요한 문제

### 장애 감지
- 분산 시스템에서는 노드 사이에 멀티캐스팅 채널을 구축해서 서로 장애를 감지할 수 있음
    + 서버가 많을 때는 비효율적인 방법
- gossip protocol 같은 분산형 장애 감지 솔루션이 효율적입
    + 각 노드는 멤버십 목록을 유지. 멤버심 목록은 각 멤버 ID와 해당 멤버의 heartbeat counter 쌍의 목록임
    + 각 노드는 주기적으로 자신의 heartbeat counter를 증가 시킴
    + 각 노드는 무작위로 선정된 노드들에게 주기적으로 자기의 heartbeat counter 목록을 보냄
    + heartbeat counter 목록을 받은 노드는 멤버십 목록을 최신화
    + 어떤 멤버의 heartbeat counter 값이 지정된 시간 동안 갱신되지 않으면 해당 멤버는 장애 상태인 것으로 간주

### 일시적 장애 처리
- 장애를 감지한 시스템은 가용성을 보장하기 위해 필요한 조치를 해야 함
- 엄격한 정족수 접근법을 쓴다면 읽기와 쓰기 연산을 금지
- 느슨한 정족수 접근법을 쓴다면 쓰기 연산을 수행할 W개의 서버와 읽기 연산을 수행할 R개의 건강한 서버버를 해시 링에서 고름
- 네트워크나 서버 문제로 장애 상태인 서버로 가는 요청은 다른 서버로 우회
    + 해당 시간동안 발생한 변경 사항은 복구되었을 때 일괄 반영하여 데이터 일관성 보존
    + 이를 위해 연산을 처리한 서버는 단서를 남겨둠
    + 이런 장애 처리 방안을 단서 후 임시 위탁 기법이라 부름

### 영구 장애 처리
- hinted handoff 기법은 일시적 장애를 처리하기 위한 방법
- 영구적인 노드 장애 처리에는 반-엔트로피(anti_entropy) 프로토콜을 구현하여 사본들을 동기화
    + 사본들을 비교하여 최신 버전으로 갱신하는 과정
    + 사본 간의 일관성이 망가진 상태를 탐지하고 전송 데이터의 양을 줄이기 위해서 Merkle 트리를 사용

```
머클 트리
- 해시 트리라고도 불리는 머클 트리는 각 노드에 그 자식 노드들에 보관된 값의 해시 또는 자식 노드들의 레이블로부터 계산된 해시 값을 레이블로 붙여두는 트리이다. 해시 트리를 사용하면 대규모 자료 구조의 내용을 효과적이면서도 보안상 안전한 방법으로 검증할 수 있다
```
1. 키 공간을 묶어서 버킷으로 나눔
2. 버킷별로 해시값을 계산한 후, 해당 버킷의 합을 다시 해시하여 해당 해시 값을 레이블로 갖는 노드를 만듬
3. 상향식으로 자식 노드의 레이블로부터 새로운 해시 값을 계산하여 이진 트리를 구성
4. 이렇게 완성된 두 머클 트리를 루트 노드부터 비교해서 틀린 부분만 찾아나감

### 데이터 센터 장애 처리
- 데이터 센터는 다양한 이유로 장애가 발생할 수 있다.
- 장애에 대응할 수 있는 시스템을 만들려면 여러 데이터 센터에 다중화하는 것이 중요

