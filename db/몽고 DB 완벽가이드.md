# Chapter 1 몽고DB 소개
* 몽고 DB는 강력하고 유연하며 확장성 높은 범용 데이터베이스이다
* 보조 인덱스, 범위 쿼리, 정렬, 집계, 공간 정보 인덱스 등을 확장 기능과 결합

## 1.1 손쉬운 사용
* 몽고 DB는 `도큐먼트 지향` 데이터베이스다
* 분산 확장을 쉽게 하기 위함
* 행 개념 대신에 보다 유연한 모델인 도큐먼트를 사용
* 내장 도큐먼트와 배열을 허용함으로써 도큐먼트 지향 모델은 복잡한 계층 관계를 하나의 레코드로 표현
* 고정된 스키마가 없음. 필요 시 쉽게 필드를 추가하거나 제거할 수 있음

## 1.2 확장 가능한 설계
* 저장할 데이터가 증가함에 따라, 데이터베이스를 어떻게 확장할 것인가와 같은 어려운 의사 결정을 해야 하는 상황에 직면함
* 스케일 업 or 스케일 아웃 중 선택해야 함
    * 스케일 업은 단순하고 쉽지만 비싸고 물리적인 한계가 있음
    * 스케일 아웃은 경제적이고 확장이 용이함. 하지만 관리가 어려움
* 몽고DB는 분산 확장을 염두에 두고 설계
* 기존에 배포된 애플리케이션의 토폴로지를 변경할 때도 애플리케이션 로직은 그대로 유지 가능

## 1.3 다양한 기능
* 몽고 DB는 CRDU 외에도 DBMS의 대부분의 기능과 더불아 아래 기능들을 제공
* 인덱싱
    * 일반적으로 보조 인덱스를 지원
    * 고유, 복합, 공간 정보, 전문 인덱싱 기능도 제공
* 집계
    * 데이터 처리 파이프라인 개념을 기반으로 한 집계 프레임워크를 제공
* 특수한 컬렉션 유형
    * 특정 시간에 만료해야 하는 데이터에 대해 유효 시간(TTL) 지원
    * 기준 필터와 일치하는 도큐먼트에 한정된 부분 인덱스 지원
* 파일 스토리지
    * 큰 파일과 파일 메타데이터를 편리하게 저장하는 프로토콜을 지원
* RDB에 사용되는 일부 기능, 특히 복잡한 조인은 존재하지 않음

## 1.4 고성능
* 몽고 DB에서는 동시성과 처리량을 극대화하기 위해 와이어드타이거 스토리지 엔진에 기회적 락을 사용

# Chapter 2 몽고DB 기본
* 몽고 DB 데이터의 기본 단위는 도큐먼트이며, RDB의 행과 유사
* 같은 맥락에서 컬렉션은 동적 스키마가 있는 테이블과 같음
* 몽고 DB의 단일 인스턴스는 자체적인 컬렉션을 갖는 여러 개의 독립적인 데이터베이스를 호스팅
* 모든 도큐먼트는 컬렉션 내에서 고유한 특수키인 "_id"를 가짐
* 몽고 DB는 몽고 셸이라는 도구와 함께 배포

## 2.1 도큐먼트
* 도큐먼트 : 정렬된 키와 연결된 값의 집합
* 도큐먼트 표현 방식 : 맵, 해시, 딕셔너리 같은 자료구조
* 도큐먼트의 키는 문자열. 아래를 제외한 UTF-8이면 가능
    * \0(null) 미포함, \0은 키의 끝을 나타내는 데 사용
    * .과 $는 예약어
* 데이터형과 대소문자를 구분
* 키가 중복될 수 없음

## 2.2 컬렉션
* 도큐먼트의 모음
* 도큐먼트가 행에 대응된다면 컬렉션은 테이블에 대응

### 2.2.1 동적 스키마
* 컬렉션은 동적 스키마를 가짐
* 하나의 컬렉션 내 도큐먼트들이 모두 다른 구조를 가질 수 있다
* 도큐먼트들의 키, 키의 개수, 데이터형의 값은 모두 다름
* 다른 구조의 도큐먼트라도 같은 컬렉션에 저장하면 안되는 이유
    * 같은 컬렉션에 다른 종류의 도큐먼트를 저장하면 개발자와 관리자에게 번거로움
    * 컬렌션별로 목록을 뽑으면 빠름
    * 같은 종류의 데이터를 하나의 컬렉션에 모아두면 데이터 지역성에 좋다
    * 인덱스를 만들면 도큐먼트는 특정 구조를 가져야 함

### 2.2.2 네이밍
* 컬렉션은 이름으로 식별
* 어떤 UTF-8 문자든 쓸 수 있지만 제약 이있음
* 제약
    * 빈 문자열은 안됨
    * \0(null) 안됨
    * system.은 예약어라 안됨
    * $는 예약어라 안됨

**서브 컬렉션**
* 서브컬렉션의 네임스페이스에 .(마침표) 문자를 사용해 컬렉션을 체계화한다.
* 예로 블로그 기능이 있는 애플리케이션은 `blog.posts`와 `blog.authors`라는 컬렉션을 가짐
* 서브컬렉션은 몽고DB의 데이터를 체계화하는 좋은 방법

## 2.3 데이터베이스
* 몽고DB는 데이터베이스에 컬렉션을 그룹지어 놓음
* 몽고 DB의 단일 인스턴스는 여러 데이터베이스를 호스팅 할 수 있음
* 각 데이터베이스를 완전히 독립적으로 취급 가능
* 데이터베이스 이름 규칙
    * 어떤 UTF-8 문자열 가능
    * 빈 문자열 안됨
    * 다음 문자 안됨. /, \, ., ' ', *, <, >, :, |, ?, $, (single space), \0(null)
    * 대소문자 구별
    * 최대 64바이트
* 직접 접근할 수 있지만 예약된 데이터베이스 이름
    * admin : 인증과 권한 부여 역할
    * local : 단일 서버에 대한 데이터를 저장
    * config : 샤딩된 몽고DB 클러스터는 config 데이터베이스를 샤용해 각 샤드의 정보를 저장

## 2.4 몽고DB 시작
* 서버를 시작하려면 유닉스 명령행 환경에서 mongod 실행 파일 실행
* mongod는 인수 없이 실행하면 기본 데이터 디렉터리로 /data/db를 사용
* 데이터 디렉터리가 없거나 쓰기 권한이 없을 때는 서버가 시작되지 않음
* 기본 포트는 27017
* mongod 서버를 실행한 셸에서 `Ctrl` + `C`를 누르면 graceful down 됨

* brew를 이용한 Mongo DB 설치 및 실행, 종료
```
brew tap mongodb/brew
brew update
brew install mongodb-community@5.0
//자동
brew services start mongodb-community@5.0
brew services stop mongodb-community@5.0

//수동 - Apple M1
mongod --config /opt/homebrew/etc/mongod.conf --fork
```
## 2.5 몽고DB 셸 소개
* 몽고DB는 명령행에서 몽고DB 인스턴스와 상호작용하는 자바스크립트 셸을 제공

### 2.5.1 셸 실행
* 책에는 mongo를 실행하면 된다 하는데 6버전 부터는 mongosh 인듯
* 셸은 완전한 자바스크립트 해석기임

### 2.5.2 몽고DB 클라이언트
* 셸은 독자적으로 쓸 수 있는 몽고DB 클라이언트
* 셸은 시작할 때 몽고DB 서버의 test 데이터베이스에 연결. 데이터베이스 연결을 전역 변수 db에 할당
```
> db
test
```
* 데이터베이스 선택 작업
```
> use video
switched to db video
>db
video
```
* 자바스크립트 셸이므로 변수 이름을 입력하면 표현식으로 평가.
* 아래와 같이 DB 변수에서 컬렉션에 접근
```
> db.movies
```

### 2.5.3 셸 기본 작업
* 셸에서 데이터를 조작하거나 보려면 CRUD의 네 가지 기본적인 작업을 함

**생성, Create**
* `insertOne` 함수는 컬렉션에 도큐먼트를 추가
* 영화를 저장한다고 가정
    * movie라는 지역 변수를 생성하고 객체를 할당
    ```
    movie = {"title":"연가시", "director":"봉준호","year":2018}
    ```
    * 위 객체를 `insertOne` 함수를 이용해서 movies 컬렉션에 저장
    ```
    > db.movies.insertOne(movie)
    ```
    * 데이터베이스에 저장된 컬렉션에서 find를 호출해서 확인
    ```
    > db.movies.find().pretty()
    ```

**읽기, Read**
* `find`와 `findOne`은 컬렉션을 쿼리하는 데 사용
* 컬렉션에서 단일 도큐먼트 읽기
```
> db.movies.findOne()
```
* `find`와 `findOne`은 `쿼리 도큐먼트` 형태로 조건 전달도 가능

**갱신, Update**
* 게시물을 갱신하려면 `updateOne`을 사용. 최소 2개의 매개변수 필요
* 첫 번째는 수정할 도큐먼트를  찾는 기준, 두 번째는 갱신 작업을 설명하는 도큐먼트
* 앞서 만든 영화에서 리뷰 기능을 사용하기로 결정했다 가정
```
> db.movies.updateOne({title: "연가시"}, {$set: {revies:[]}})
```

**삭제, Delete**
* deleteOne과 deleteMany는 도큐먼트를 데이터베이스에서 영구적으로 삭제
* 두 함수 모두 필터 도큐먼트로 삭제 조건을 지정
```
> db.movies.deleteOne({title: "연가시"})
```
* 필터와 일치하는 모든 도큐먼트를 삭제하려면 deleteMayn 사용

## 2.6 데이터 형
* 몽고DB는 도큐먼트의 값으로 다양한 데이터형을 지원

### 2.6.1 기본 데이터형
* 몽고DB에서 도큐먼트는 자바스크립트 객체와 개념적으로 닮았다는 점에서 JSON과 닮았다라고 생각할 수 있음
* 몽고DB는 JSON의 키/값 쌍 성질을 유지하면서 추가적인 데이터형을 지원
* null : null값과 존재하지 않는 필드를 표현
```json
{"x": null}
```
* 불리언 : 참과 거짓 값에 사용
```json
{"x": true}
```
* 숫자 : 셸은 64비트 부동소수점 수를 기본으로 사용
```json
{"x": 3}
{"x": 3.14}
```
* 4바이트 혹은 8바이트의 부호 정수는 각각 NumberInt 혹은 NumberLong 클래스 사용
```json
{"x": NumberInt("3")}
{"x": NumberLong("3")}
```
* 문자열 : 어떤 UTF-8 문자열이든 문자열형으로 표현할 수 있다
```json
{"x": "foobar"}
```
* 날짜 : 몽고 DB는 1970년 1월 1일부터의 시간을 1/1000초 단위로 나타내는 64비트 정수로 날짜를 저장
```json
{"x": new Date()}
```
* 정규 표현식 : 쿼리는 자바스크립트의 정규 표현식 문법을 사용할 수 있음
```json
{"x": /foobar/i}
```
* 배열 : 값의 셋이나 리스트를 배열로 표현할 수 있다
```json
{"x": ["a","b","c"]}
```
* 내장 도큐먼트 : 도큐먼트는 부모 도큐먼트의 값으로 내장된 도큐먼트 전체를 포함 할 수 있음
```json
{"x": {"foo":"bar"}}
```
* 객체 ID : 객체 ID는 도큐먼트용 12바이트 ID
```json
{"x": ObjectId()}
```
* 이진 데이터 : 임의의 바이트 문자열. 셸에서 조작 불가능
* 코드 : 임의의 자바스크림트 코드를 포함할 수 있음
```json
{"x": function() { /* ... */}}
```

### 2.6.2 날짜
* 자바스크립트에서 Date 클래스는 몽고 DB의 날짜를 표현하는데 사용
* 새로운 데이트 객체를 생성할 때는 항상 `new Date()` 호출

### 2.6.3 배열
* 배열은 서로 다른 데이터형을 값으로 포함할 수 있음
```json
{"things":["pie", 3.14]}
```
* 배열에 쿼리하거나 배열의 내용을 이용해 인덱스를 만들 수 있다

### 2.6.4 내장 도큐먼트
* 키에 대한 값이 되는 도큐먼트를 내장 도큐먼트라 함
```json
{
    "name": "John Doe",
    "address":{
        "street": "123 Park Street",
        "city": "Anytown",
        "state": "NY"
    }
}
```
* 몽고 DB는 내장 도큐먼트의 구조를 이해하고 인덱스를 구성하고 쿼리하며, 갱신하기 위해 내장 도큐먼트 내부에 접근
* 관계형 DB에는 이가 분리된 두 개의 행으로 모델링 됨
* 몽고DB에서는 많은 데이터 반복이 생길 수 있음

### 2.6.5 _id와 ObjectId
* 몽고DB에 저장된 모든 도큐먼트는 "_id" 키를 가진다
* "_id" 키 값은 어떤 데이터형이여도 상관없지만 "ObjectId"가 기본
* 하나의 컬렉션에서 모든 도큐먼트는 고유한 "_id" 값을 가짐

**ObjectIds**
* ObjectId는 "_id"의 기본 데이터형
* ObjectId 클래스는 가벼우면서, 여러 장비에 걸쳐 전역적으로 고유하게 생성하기 쉽게 설계
* 몽고DB는 분산 데이터베이스로 설계됐기 때문에 샤딩된 환경에서 고유 식별자를 생성하는 것이 매우 중요
* ObjectId는 12바이트 스토리지를 이용. 24자리 16진수 문자열 표현이 가능. 바이트당 2자리를 사용
* 여러 개의 새로운 ObjectID를 연속으로 생성하면 매번 마지막 숫자 몇 개만 바뀜
* 몇 초 간격을 두고 생성하면 ObjectID의 중간 숫자 몇 개가 바뀜
* 도큐먼트를 입력할 때 "_id" 키를 명시하지 않으면 입력된 도큐먼트에 키가 자동으로 추가

## 2.7 몽고DB 셸 사용
* 원격 몽고 서버 접속
```
mongosh some-host:port/db
```
* mongod에 연결하지 않고 시작하기
```
mongosh --nodb
conn = new Mongo("some-host:port")
db = conn.getDB("test")
```

## 2.7.1 셸 활용 팁
* mongosh는 단순하게 보면 자바스크립트 셸이므로 자바스크립트 문서 참조해도 됨
* help 입력하면 셸에 내장된 도움말 볼 수 있음
* 데이터베이스 수준의 도움말은 db.help()
* 컬렉션 수준의 도움말은 db.foo.help()
* 함수의 기능을 알고 싶으면 함수명을 괄호없이 입력하면 됨
* 함수의 시그니처는 함수명.help로 확인 가능

## 2.7.2 셸에서 스크립트 실행하기
* 자바 스크립트 파일을 셸로 전달해 실행 가능
```m
mongosh script.js
```
* load 함수를 사용해서 대화형 셸에서 스크립트를 실행할 수 있음
```m
> load('script.js')
```
* 스크립트는 db 변수에 대한 접근은 가능하지만 use db나 show collections와 같은 셸 보조자는 작동하지않음

# Chapter 3 도큐먼트 생성, 갱신, 삭제

## 3.1 도큐먼트 삽입
* 삽입은 몽고DB에 데이터를 추가하는 기본 방법
* 컬렉션의 insertOne 메서드 사용
```m
db.movies.insertOne({"title": "Batman"})
```
* 도큐먼트에 "_id" 키가 자동으로 추가

### 3.1.1 insertMany
* 여러 도큐먼트를 컬렉션에 삽입하려면 insertMany로 도큐먼트 배열을 전달
```m
db.movies.insertMany(
    [
        {"title":"Iron Man"},
        {"title":"Batman"},
        {"title":"Hulk"}
    ]
)
```
* 몽고DB의 버전에 따라 메시지의 용량에 제한이 있으므로 한 번에 일괄 삽입 할 수 있는 크기에 제한이 있다. 
* 제한된 용량보다 크면 드라이버가 여러 개로 분할
* 삽입시에 정렬 or 비정렬을 선택할 수 있다. 기본값은 정렬
* 정렬 삽입시에 중간에 에러 발생하면 해당 발생 지점부터 멈춤
* 비정렬 삽입시에 중간에 에러 발생하면 해당 도큐먼트 제외하고 다 삽입 시도

### 3.1.2 삽입 유효성 검사
* 몽고 DB는 삽입된 데이터에 최소한의 검사를 수행
* 도큐먼트의 기본 구조를 검사해 "_id" 필드가 존재하지 않으면 추가하고, 모든 도큐먼트는 16메가바이트보다 작아야 하므로 크기 검사를 함
    * [MongoDB 6.0](https://www.mongodb.com/docs/manual/core/document/) 기준으로 아직 16 megabyte. 600쪽 짜리 책이 3MB 정도 함
* 도큐먼트의 Binary JSON(BSON) 크기를 보려면 셸에서 object.bsonsize(doc)를 실행
* [MongoDB 6.0](https://www.mongodb.com/docs/v6.0/reference/operator/aggregation/bsonSize/?_ga=2.178847844.1309917206.1662172054-1070121506.1661954868&_gac=1.222154986.1662172054.Cj0KCQjw08aYBhDlARIsAA_gb0f7LPQVKS-MrGyglm8EGGAAKebt9V5XPTbslA_4WUHoHt0I31dwMA0aAj7REALw_wcB)에서 bsonsize 보는 방법

### 3.1.3 삽입
* 몽고DB 3.0 이전 버전에서는 삽입 할 때 insert 사용
* 호환성 지원 때문에 사용 할 수는 있지만 insertOne or insertMany를 사용

## 3.2 도큐먼트 삭제
* deleteOne과 deleteMany를 이용해서 삭제 가능
```m
db.movies.deleteOne({"_id": ObjectId("6312b034452fd87b69e1978c")})
```
* deleteOne은 필터에 의해 여러개가 걸리면 첫 번째 도큐먼트만 삭제
* deleteMany는 필더에 걸린거 전부 삭제
* 몽고DB 3.0 이전 버전에서는 삭제할 때 remove 사용
* 호환성 지원 때문에 사용 할 수는 있지만 deleteOne or deleteMany를 사용

### 3.2.1 drop
* deleteMany를 사용해 컬렉션의 모든 도큐먼트 삭제
* 전체 컬렉션을 삭제하려면 drop을 사용하는 편이 더 빠름
```m
db.movies.drop()
```

## 3.3 도큐먼트 갱신
* 도큐먼트는 updateOne, updateMany, replaceOne과 같은 갱신 메서드를 사용해 변경
* updateOne과 updateMany는 필터 도큐먼트를 첫 번째 매개변수로, 변경 사항을 설정하는 수정자 도큐먼트를 두 번째 매개변수로 사용
* replaceOne도 첫 번째 매개변수로 필터를 사용하지만 두 번째 매개변수는 필터와 일치하는 도큐먼트를 교체할 도큐먼트
* 갱신은 원자적으로 이뤄짐. 두 개의 갱신이 동시에 발생하면 서버에 먼저 도착한 요청이 적용된 후 다음 요청이 적용

### 3.3.1 도큐먼트 치환
* replaceOne은 도큐먼트를 새로운 것으로 완전히 치환함
* replaceOne의 필터에 2개 이상의 도큐먼트가 걸리면 갱신 실패. 고유한 값으로 시도해야됨
* "_id" 값이 컬렉션 기본 인덱스의 기초를 형성하므로 필터에 "_id"를 사용해도 효율적이다

### 3.3.2 갱신 연산자
* 부분 갱신에는 원자적 갱신 연산자를 사용
* 갱신 연산자는 키를 변경, 추가, 제거하고 배열과 내장 도큐먼트를 조작하는 복잡한 갱신 연산을 지정하는 데 사용하는 특수키다

**`$Set` 제한자 사용하기**
* `$Set`은 필드 값을 설정.
* 필드가 존재하지 않으면 새 필드 생성
```m
db.movies.updateOne(
    {"title":"Iron Man"}, 
    {
        "$set": {
            "description":"Beeem!"
        }
    }
)
```

**증가와 감소**
* `$inc` 연산자는 이미 존재하는 키의 값을 변경하거나 새 키를 생성하는 데 사용.
* 키 값은 무조건 숫자여야 함
```m
db.movies.updateOne(
    {"title":"Iron Man"}, 
    {"$inc": {"score":50}}
)
```

**배열 연산자**
* 요소 추가하기 : `$push`는 배열이 이미 존재하면 배열 끝에 요소를 추가하고, 존재하지 않으면 새로운 배열을 생성
```m
db.movies.updateOne(
    {"title":"Iron Man"}, 
    {"$push": {"actors": "toni"}}
)
```
* `$push`에 `$each` 제한자를 사용하면 작업 한 번으로 값을 여러 개 추가할 수 있음
```m
db.movies.updateOne(
    {"title":"Iron Man"}, 
    {"$push": {"actors":{"$each": ["toni", "stark"]}}}
)
```
* `$slice`를 이용해서 도큐먼트 내에 큐를 생성해 top N 목록을 만들 수 있음
```m
db.movies.updateOne(
    {"title":"Iron Man"}, 
    {"$push": {"actors":{"$each": ["toni", "stark"],
                    "$slice": -10}}}
)
```
* `$sort`를 이용해서 정렬된 상태로 추가할 수 있음
* 1 : 오름차순
* -1 : 내림차순
```m
db.movies.updateOne(
    {"title":"Iron Man"}, 
    {
        "$push": {
            "actors":
            {
                "$each": [{"name":"toni", "age":30}, 
                            {"name":"startk", "age":40}],
                "$slice": -10,
                "$sort": {"age": -1}
            }
        }
    }
)
```
* 배열을 집합으로 사용하기
* `$ne`를 사용하면 값을 추가하면서 중복을 제거
```m
db.movies.updateOne({"actors": {"$ne": "toni"}}, {"$push": {"actors": {"name":"Jone", "age": 20}}})
```
* `$addToSet`을 사용하면 `$ne`가 작동하지 않을 때나 무슨 일이 얼아났는지 더 잘 알수 있을 때 유용
* `$addToSet`을 사용하면 배열에 중복을 피할 수 있음
```m
db.movies.updateOne({"_id":ObjectId("6312b034452fd87b69e1978d")}, {"$addToSet": {"actors": {"name":"Jone", "age": 20}}})
```
* `$pop`: 배열에서 요소 제거하기
    * {"$pop":{"key":1}} : 배열의 마지막 요소부터 제거
    * {"$pop":{"key":-1}} : 배열의 첫 요소부터 제거
* `$pull`: 주어진 조건에 맞는 배열 요소를 모두 제거
```
db.lists.insertOne({"todo":["dishes", "laundry", "dry cleaning"]})
db.lists.updateOne({}, {"$pull":{"todo":"laundry"}})
```
**배열의 위치 기반 변경**
* 위치를 이용하거나 위치 연산자($)를 사용해서 변경
* 배열 인덱스는 기준이 0
* 배열 요소는 인덱스를 도큐먼트의 키처럼 사용
```m
// post를 찾아서 0번째 comments의 votes를 1 증가
db.blog.updateOne({"post": post_id},
    {"$inc":{"comments.0.votes": 1}})
```
* `$`: 쿼리 도큐먼트와 일치하는 배열 요소 및 요소의 위치를 알아내서 갱신하는 위치 연산자
```m
db.blog.updateOne({"comments.autho": "John"},
        {"$set": {"comments.$.author": "Jim}})
```

**배열 필터를 이용한 갱신**
* arrayFilters를 이용해 특정 조건에 맞는 배열 요소를 갱신할 수 있음
* `elem`: 배열의 각 일치 요소에 대한 식별자
```m
// 투표값이 -5 이하인 경우 hidden에 true 설정
db.blog.updateOne(
    {"post": post_id},
    {"$set": {"comments.$[elem].hidden": true}},
    {
        arrayFilters: [ {"elem.votes": { $lte: -5 }}]
    }
)
```

### 3.3.3 갱신 입력
* 갱신 조건에 맞는 도큐먼트가 존재하지 않을 때는 쿼리 도큐먼트와 갱신 도큐먼트를 합쳐서 새로운 도큐먼트를 생성
* 조건에 맞는 도큐먼트가 있으면 일반적인 갱신 수행
* race condition을 피할 수 있음
* updateOne과 updateMany의 세 번째 매개변수는 옵션 도큐먼트. 여기에 갱신 입력을 지정
```
db.analytics.updateOne({"url":"/blog"}, {"$inc": {"pageviews": 1}},
    {"upsert": true})
```
* `$setOnInsert`: 도큐먼트가 삽입될 때 필드 값을 설정하는 데만 사용하는 연산자
```m
db.users.updateOne({}, {"$setOnInsert": {"createdAt": new Date()}},
    {"upsert": true})
```

### 3.3.4 다중 도큐먼트 갱신
* `updateMany`: 조건에 맞는 모든 도큐먼트 수정
* 사용법은 `updateOne`이랑 동일

# Chapter 4 쿼리

## 4.1 find 소개
* 몽고DB에서 find 함수는 쿼리에 사용
* 쿼리는 컬렉션에서 도큐먼트의 서브셋을 반환
* 빈 쿼리 도큐먼트({})는 컬렉션 내 모든 것과 일치
* 쿼리 도큐먼트에 여러 키/값 쌍을 추가해 검색을 제한할 수 있다
```m
// "age"가 27인 모든 도큐먼트
db.users.find({"age": 27})
```
```m
// "username"이 "joe"인 모든 도큐먼트
db.users.find({"age": 27})
```
```m
// "age"가 27 AND "username"이 "joe"인 모든 도큐먼트
db.users.find({"age": 27})
```

### 4.1.1 반환받을 키 지정
* 원하는 키/값 정보는 두 번째 매개변수에 원하는 키를 지정하면 됨
```m
// 컬렉션에서 "username"과 "email" 키의 값만 추출
db.users.find({}, {"username": 1, "email": 1})
```
* "_id" 키는 지정하지 않아도 항상 반환됨
* 특정 키/값 쌍을 제외한 결과를 얻을 수 있음
```m
db.users.find({}, {"fatal_weakness" : 0})
```

### 4.1.2 제약 사항
* 데이터베이스에서 쿼리 도큐먼트 값은 반드시 상수여야 함. 도큐먼트 내 다른 키의 값을 참조할 수 없음

## 4.2 쿼리 조건

### 4.2.1 쿼리 조건절
* < : "$lt"
* <= : "$lte"
* > : "$gt"
* >= : "$gte"
```m
db.users.find({"age": {"$gte": 18, "$lte" : 30}})
```
```m
start = new Date("01/01/2007")
db.users.find({"registered": {"$lt": start}})
```
* != : "$ne"
```m
db.users.find({"username": {"$ne": "joe"}})
```

### 4.2.2 OR 쿼리
* "$in" : 포함. 하나의 키를 다양한 값과 비교
* "$nin" : 미포함. 하나의 키를 다양한 값과 비교
* "$or" : 여러 키를 주어진 값과 비교
```m
// 포함
db.raffle.find({"ticket_no": {"$in": [725, 542, 390]}})
// 미포함
db.raffle.find({"ticket_no": {"$nin": [725, 542, 390]}}) 
// or
db.raffle.find({"$or": [{"ticket_no": 725}, {"winner": true}]})
```

### 4.2.3 $not
* "$not"은 메타 조건절이며 어떤 조건에도 적용할 수 있음
```
db.users.find({"id_num": {"$not" : {"$mod": [5, 1]}}})
```

## 4.3 형 특정 쿼리
* 도큐먼트 내에서 다양한 데이터형 사용 가능. 일부 데이터형은 쿼리 시 형에 특정하게 작동

### 4.3.1 null
* null은 스스로와 일치하는 것을 찾음
```m
db.c.find({"y": null})
```
### 4.3.2 정규 표현식
* "$regex"는 쿼리에서 패턴 일치 문자열을 위한 정규식 기능을 제공
```m
db.users.find({"name": {"$regex": /joe/i }})
```
* 자바스크립트에서 정규표현식이 제대로 동작하는지 확인 하는게 좋음
* 접두사 정규 표현식에 쿼리 인덱스 활용 가능

### 4.3.3 배열에 쿼리하기
* 배열 요소 쿼리는 스칼라 쿼리와 같은 방식으로 동작하도록 설계
```m
db.food.insertOne({"fruit": ["apple", "banana", "paech"]})
db.food.find({"fruit": "banana"})
```
* $all 연산자 : 2개 이상의 배열 요소가 일치하는 배열을 찾을 때 사용
```m
db.food.find({"fruit": {$all: ["banana","peach"]}})
```
* $size 연산자 : 특정 크기의 배열을 쿼리하는 조건
```m
db.food.find({"fruit": {"$size": 3}})
```
* $slice 연산자 : 배열 요소의 부분집합을 반환받을 수 있음
```m
// 처음 10개
db.blog.posts.findOne(criteria, {"comments": {"$slice" : 10}})
// 마지막 10개
db.blog.posts.findOne(criteria, {"comments": {"$slice" : -10}})
// 24 ~ 33째 까지 반환
db.blog.posts.findOne(criteria, {"comments": {"$slice" : [23, 10]}})
```
* $ : 배열 요소의 인덱스를 알고 있다면 인덱스가 일치하는 배열 요소의 반환.
```m
db.blog.posts.findOne({"comments.name": "bob", {"comments.$": 1} })
```

**배열 및 범위 쿼리의 상호작용**
```m
{"x": 5}
{"x": 15}
{"x": 25}
{"x": [5, 25]}
```
* 위와 같은 데이터가 있을 때 아래처럼 쿼리하면 15, [5, 25]가 나옴
```m
db.xs.find({"x": {$gt: 10, $lt: 20}})
```
* $elemMatch로 막을 수 있지만 배열이 아니면 일치시키지 않음
```m
db.xs.find({"x": {$elemMatch: {$gt: 10, $lt: 20}}})
```

### 4.3.4 내장 도큐먼트에 쿼리하기
* 도큐먼트 전체를 대상으로 하는 방식과 도큐먼트 내 키/값 쌍 각각을 대상으로 하는 방식으로 나뉨
```m
// 전체 도큐먼트를 대상으로 하는 쿼리
db.people.find({"name":{"first":"joe", "last":"Schmoe"}})
// 내장 도큐먼트에 쿼리하는 방식
db.people.find({"name.first": "joe", "name.last":"Schmoe"})
```

## $4.4 where 쿼리
* $where 절을 사용해 임의의 자바스크립트를 쿼리의 일부분으로 실행하면 모든 쿼리를 표현할 수 있음
* 보안에 취약함
* 일반 쿼리보다 많이 느리니 반드시 필요한 경우가 아니면 자제

## 4.5 커서
* 커서를 사용해 find의 결과를 반환
```m
var cusor = db.foo.find()

while(cursor.hasNext()){
    obj = cursor.next()
    // something
}
```
* cursor 클래스는 자바스크립트의 반복자 인터페이스를 구현해서 forEach 가능

### 4.5.1 제한, 건너뛰기, 정렬
* limit : 결과 개수 제한
```m
db.c.find().limit(3)
```
* skip : 특정 개수만큼 건너띄고 나머지 반환
```m
db.c.find().skip(3)
```
* sort : 객체를 매개변수로 받아서 정렬. 
    - 매객변수는 키/값 쌍. 
    - 키는 키의 이름. 
    - 값은 정렬 방향. 
    - 오름차순 : 1, 내림차순 : -1
    - 큰 수를 건너뛰면 비효율적
```m
db.c.find().sort({username: 1, age: -1})
```

**비교 순서**
* 몽고DB에는 데이터형을 비교하는 위계 구조가 있음
* 데이터형이 섞여 있는 키는 미리 정의된 순서에 따라 정렬
    1. 최솟값
    2. null
    3. 숫자
    4. 문자열
    5. 객체/도큐먼트
    6. 배열
    7. 이진 데이터
    8. 객체 ID
    9. 불리언
    10. 날짜
    11. 타임스탬프
    12. 정규 표현식
    13. 최댓값

### 4.5.2 많은 수의 건너뛰기 피하기
* skip은 생략된 결과물을 모두 찾아 폐기하므로 결과가 많이 느려짐

**cursor를 이용한 방법**
* date 키를 기준으로 내림차순 정렬된 도큐먼트가 있음
```m
var page1 = db.foo.find().sort({"date": -1}).limit(100)

var latest = null

// 1 페이지 출력
while (page1.hasNext()){
    latest = page1. next()
    display(latest)
}

// 다음 페이지는 이전 페이지의 마지막 날짜를 기준으로 가져옴
var page2 = db.foo.find({"date": {"$lt": latest.data}})
page2.sort({"date": -1}).limit(100)
```

### 4.5.3 종료되지 않는 커서
* 커서는 클라이언트측 커서와, 데이터베이스 커서가 있음
* 서버 측에서 보면 커서는 메모리와 리소스를 점유
* 커서가 더는 가져올 결과가 없거나 클라이언트로부터 종료 요청을 받으면 데이터베이스는 점유하고 있던 리소스를 해제
* 서버 커서를 종료하는 몇가지 조건
    * 조건에 일치하는 결과를 모두 살펴본 후 스스로 정리
    * 커서가 클라이언트측에서 유효 영역을 벗어난 경우
    * 10분 동안 활동이 없는 경우

# Chapter 5 인덱싱

## 5.1 인덱싱 소개
* 데이터베이스 인덱스는 책의 인덱스와 유사
* 엄청난 양의 명령을 더 빠르게 쿼리할 수 있음
* 인덱스를 사용하지 않는 쿼리를 컬렉션 스캔이라 함. 
    - RDB에서는 Full Table Scan 정도가 될듯?
    - 너무 느림
* explain 함수로 쿼리 실행 계획 확인
```m
db.users.find({"username": "user01"}).explain("executionStats")
```

### 5.1.1 인덱스 생성
* `createIndex` : 인덱스를 만드는 컬렉션 메서드
```m
db.users.createIndex({"username": 1})
```

### 5.1.2 복합 인덱스 쇅
* 2개 이상의 필드로 구성된 인덱스
* 각 인덱스 항목은 설정된 키를 포함하고 레코드 식별자를 가리킴
* 레코드 식별자는내부에서 스토리지 엔진에 의해 사용
* 몽고DB는 인덱스를 어느 방향으로도 쉽게 탐색할 수 있음

### 5.1.3 몽고DB가 인덱스를 선택하는 방법
* 쿼리가 들어오면 쿼리 모양을 확인
    * 검색할 필드, 정렬 여부 등의 추가 정보가 있음
* 이 정보를 기반으로 쿼리를 충족하는 데 사용할 인덱스 후보 집합을 식별
* 인덱스 후보를 대상으로 쿼리 플랜을 만듬
* 병렬 스레드에서 쿼리 실행
* 제일 먼저 실행된 쿼리와 동일한 모양을 가진 쿼리에 사용할 인덱스로 사용
* 서버는 쿼리 플랜의 캐시를 유지
* 컬렉션과 인덱스가 변경되면 쿼리 플랜 캐시가 제거

### 5.1.4 복합 인덱스 사용
* 읽기와 쓰기를 가능한한 효율적으로 수행하도록 인덱스를 설계
* 인덱스를 올바르게 설계하려면 실제 워크로드에서 인덱스를 테스트하고 조정해야 함
* 모범사례
    * 인덱스의 선택성 : 특정 쿼리 패턴에서 스캔할 레코드 개수를 인덱스가 얼마나 최소화 하는지


### 5.1.5 $ 연산자의 인덱스 사용법
* $ne 쿼리는 인덱스를 잘 활용하지 못함
* $not을 사용하는 쿼리 대부분은 테이블 스캔을 수행
* $nin은 항상 테이블 스캔 수행
* 범위에 사용될 필드는 인덱스의 마지막에 놓는게 좋음
* 보통 쿼리 하나당 하나의 인덱스만 사용
    * $or는 절마다 하나씩 인덱스를 사용할 수 있음

### 5.1.6 객체 및 배열 인덱싱
* 내장 필드와 배열에 인덱스 생성 가능
```m
//서브 필드
db.users.createIndex({"loc.city": 1})
// 배열
db.users.createIndex({"comments.date" : 1})
```

## 5.2 explain 출력
* explain은 쿼리에 대한 많은 정보를 제공
* 샤딩은 쿼리를 여러 서버에서 수행하므로 explain들의 집합체를 반환
* 쿼리가 CALLSCAN이면 엔덱스 사용 안함
* isMultiKey : 다중키 인덱스 사용 여부
* nReturned : 쿼리에 의해 반환된 도큐먼트 개수
* totalDocsExamined : 몽고 DB가 디스크 내 실제 도큐먼트를 가리키는 인덱스 포인터를 따라간 횟수
* totalKeysExamin : 인덱스가 사용됐다면 살펴본 인덱스 항목 개수, 테이블 스캔을 했다면 조사한 도큐먼트 개수
* stage : 몽고DB가 인덱스를 사용해 쿼리할 수 있었는지 여부
* needYields : 쓰기 요청을 처리하도록 쿼리가 양보(yield, 일시 중지) 한 횟수
* executionTimeMillis : 쿼리하는 데 걸린 시간
* indexBounds : 인덱스가 어떻게 사용됐는지 설명

## 5.3 인덱스를 생성하지 않는 경우
* 인덱스는 데이터의 일부를 조회할 때 가장 효율적
* 인덱스가 없는 게 더 빠른 쿼리도 있음
* 인덱스가 적합한 경우 : 큰 컬렉션, 큰 도큐먼트, 선택적 쿼리
* 컬렉션 스캔이 적합한 경우 : 작은 컬렉션, 작은 도큐먼트, 비선택적 쿼리

## 5.4 인덱스 종류

### 5.4.1 고유 인덱스
* 각 값이 인덱스에 최대 한 번 나타나도록 보장
* 고유 인덱스인 _id의 인덱스는 컬렉션을 생성하면 항상 자동으로 생성
* 인덱스 버킷은 크기 제한이 있으며 제한을 넘는 인덱스 항목은 인덱스에 포함되지 않음
* 복합 고유 인덱스를 만들 수도 있음
* 고유 인덱스를 구축할 때 중복된 값이 있으면 실패함

### 5.4.2 부분 인덱스
* partialFilterExpression 옵션을 포함해서 생성

## 5.5 인덱스 관리
* 동일한 인덱스를 다시 생성하면 아무일도 안 일어남
* 데이터베이스의 인덱스 정보는 모두 system.indexes 컬렉션에 저장
    - 수정 및 제거 불가능

### 5.5.1 인덱스 식별
* 인덱슴여 : 컬렉션 내 각 인덱스는 고유하게 식별하는 이름

### 5.5.2 인덱스 변경
* dropIndex : 인덱스 제거

# Chapter 6 특수 인덱스와 컬렉션 유형
## 6.1 공간 정보 인덱스
* 2dsphere와 2d라는 공간 정보 인덱스 사용
* 2dsphere는 WGS84 좌표계를 기반으로 지표면을 모델링. 정확한 거리 계산을 할 수 있음
* 2차원 평면의 점에는 2d 인덱스 사용
* 2dsphere를 사용하면 GeoJSOn 형식으로 점, 선, 다각형의 기하 구조로 지정할 수 있다
* createIndex로 2dsphere를 사용해 공간 정보 인덱스 생성
```m
db.openStreetMap.createIndex({"loc": "2dsphere"})
```

## 6.2 전문 검색을 위한 인덱스
* 애플리케이션 사용자가 제목, 설명 등 컬렉션 내에 있는 필드의 텍스트와 일치시키는 키워드 쿼리를 하게 하려면 text 인덱스를 사용
* 텍스트를 빠르게 검색하는 기능을 제공. 언어에 적합한 토큰화, 정지 단어, 형태소 분석 등 일반적인 검색 엔진 요구 사항을 지원

### 6.2.1 텍스트 인덱스 생성
```m
db.articles.createIndex({"title": "text", "body": "text"})
```

### 6.2.2 텍스트 검색
```m
db.articles.find({"$text": {"$search": "impact crater lunar"}}, {title: 1}).limit(10)
```

## 6.3 제한 컬렉션
* 일반적인 몽고DB의 컬렉션은 자동으로 늘어나는데, 미리 생성되어 크기가 고정된 제한 컬렉션이라는 다른 형태의 컬렉션 지원. 
* 환형 큐처럼 동작

### 6.3.1 제한 컬렉션 생성
* createCollection을 이용해 명시적으로 생성
```m
db.createCollection("my_collection", {"capped": true, "size": 100000})
```

### 6.3.2 꼬리를 무는 커서
* 결과를 모두 꺼낸 후에도 종료되지 않는 특수한 형태의 커서
* tail -f와 비슷하게 결과를 지속적으로 꺼내는 기능을 수행
* 제한 컬렉션에서만 사용

## 6.4 TTL 인덱스
* TTL 인덱스를 이용해서 각 도큐먼트에 유효 시간을 설정할 수 있음
* 도큐먼트는 미리 설정한 시간에 도달하면 지워짐
* 세션 스토리지와 같은 문제를 캐싱하는 데 유용
* TTL 인덱스는 여러개 가질 수 있음

## 6.5 GridFS로 파일 저장하기
* GridFS는 몽고 DB에 대용량 이진 파일을 저장하는 메커니즘임
* 장점
    - 아키텍처 스택을 단순화 할 수 있음
    - 기존의 복제나 자동 샤딩을 이용. Failover와 분산 확장이 쉬움
    - 특정 파일시스템이 갖는 문제를 피할 수 있음
* 단점
    - 성능이 느림
    - 도큐먼트를 수정하려면 삭제하고 다시 저장해야 됨


# Chapter 7 집계 프레임워크

// TODO

# Chapter 8 트랜잭션
* 몽고 DB는 여러 작업, 컬렉션, 데이터베이스, 도큐먼트 및 샤드에서 ACID 호환 트랜잭션을 지원

## 8.1 트랜잭션 소개
* 트랜잭션은 읽기나 쓰기 작업이 가능한 데이터베이스 작업을 하나 이상 포함하는 데이터베이스의 논리적인 처리 단위다

### 8.1.1 ACID의 정의
* 트랜잭션이 진정한 트랜잭션이 되려면 ACID라는 속성을 충족
    - Atomicity, 원자성
    - Consistency, 일관성
    - Isolation, 고립성
    - Durability, 영속성

* 원자성 : 트랜잭션 내 모든 작업이 적용되거나 아무 적업도 적용되지 않도록 함
* 일관성 : 트랜잭션이 성공하면 데이터베이스가 하나의 일관성 있는 상태에서 다음 일관성 있는 상태로 이동하도록 함
* 고립성 : 여러 트랜잭션이 데이터베이스에서 동시에 실행되도록 허용하는 속성
* 영속성 : 트랜잭션이 커밋될 때 시스템 오류가 발생하더라도 모든 데이터가 유지되도록 한다

* 몽고 DB는 복제 쎄과 샤드 전체에 ACID 호환 트랜잭션이 있는 분산 데이터베이스이다

## 8.2 트랜잭션 사용법
* 몽고DB는 트랜잭션을 사용하기 위한 두 가지 API 제공
    - 코어 API라는 관계형 데이터베이스와 유사한 구문
    - 트랜잭션 사용에 권장되는 접근 방식인 콜백 API

* 코어 API는 대부분의 오류에 재시도 로직을 제공하지 않으며 개발자가 작업에 대한 로직, 트랜잭션 커밋 함수, 필요한 재시도 및 오류 로직을 작성해야 됨
* 콜백 API는 지정된 논리 세션과 관련된 트랜잭션 시작, 콜백 함수로 제공된 함수 실행, 트랜잭션 커밋을 포함해 코어 API에 비해 많은 기능을 래핑하는 단일 함수 제공

## 8.3 애플리케이션을 위한 트랜잭션 제한 조정
* 애플리케이션이 트랜잭션을 최적으로 사용하도록 매개변수 조정

### 8.3.1 타이밍과 Oplog 크기 제한
* 몽고DB 트랜잭션에는 두 가지 주요 제한 범주가 있음
    - 트랜잭션의 시간 제한
    - oplog 항목과 개별 항목에 대한 크기 제한

**시간 제한**
* 기본적인 트랜잭션 최대 실행 시간 : 1분
* transactionLifetimeLimitSeconds에 의해 제어되는 제한을 수정해 증가
* 샤드 클러스터의 경우 모든 샤드 복제 셋 멤버에 매개변수를 설정
* 제한 시간이 경과하면 정리 프로세스에 의해 중단
* 정리 프로세스는 60초 or transactionLifetimeLimitSeconds / 2 중 더 낮은 값을 주기로 실행
* commitTransaction에 maxTimeMS를 지정해 트랜잭션에 시간 제한을 명시적으로 설정

**Oplog 크기 제한**
* 몽고 DB는 트랜잭션의 쓰기 작업에 필요한 만큼 oplog 항목을 생성.
* 각 oplog 항목은 BSON 도큐먼트 크기 제한인 16메가바이트 이하여야 한다.

# Chapter 9 애플리케이션 설계
* 애플리케이션을 몽고 DB와 효율적으로 작동하도록 설계하는 방법

## 9.1 스키마 설계 고려 사항
* 애플리케이션에서 원하는 방식으로 데이터를 표현하는 방법이 가장 좋음
* 스키마를 모델링하기 전에 먼저 쿼리 및 데이터 접근 패턴을 이해
* 스키마를 설계할 때 고려할 주요 요소
    * 제약 사항 : 데이터베이스와 하드웨어 제약 사항을 이해
        - 도큐먼트 최대 크기는 16MB
        - 디스크에서 전체 도큐먼트를 읽고 씀
        - 갱신은 전체 도큐먼트를 다시 씀
        - 원자성 갱신은 도큐먼트 단위로 실행

    * 쿼리 및 쓰기의 접근 패턴 : 애플리케이션 및 더 넓은 시스템의 워크로드를 식별하고 정량화 해야 함
        - 워크로드(작업량)는 애플리케이션의 읽기와 쓰기를 모두 포함
        - 쿼리가 실행되는 시기와 빈도를 알면 가장 일반적인 쿼리를 식별할 수 있음
        - 쿼리를 식별한 후 쿼리 수를 최소화하고, 함께 쿼리되는 데이터가 동일한 도큐먼트에 저장되도록 설계를 확인
        - 동적 데이터와 정적 데이터를 분리

    * 관계 유형 : 애플리케이션 요구 사항 측면과 도큐먼트 간 관계 측면에서 어떤 데이터가 관련돼 있는지 고려
        - 쿼리하지 않고 도큐먼트를 참조하는 방법을 파악
        - 관계가 변경될 때 갱신되는 도큐먼트 개수를 파악
        - 데이터가 쿼리하기 쉬운 구조인지 고려

    * 카디널리티 : 도큐먼트와 데이터가 어떻게 관련돼 있는지 확인한 후에는 관계의 카디널리티를 고려
        - 1:1, 1:N, N:M, 1:수백만, N: 수십억인지 고려

### 9.1.1 스키마 설계 패턴
* 스키마 설계가 애플리케이션 성능에 직접 영향을 미침
* 스키마 설계 패턴
    * 다형성 패턴 : 컬렉션 내 모든 도큐먼트가 유사하지만 동일하지 않은 구조를 가질 때 적합
    * 속성 패턴 : 정렬하거나 쿼리하려는 도큐먼트의 필드의 서브셋이 있는 경우, 정렬하러는 필드가 도큐먼트의 서브셋에만 존재하는 경우 또는 두 조건이 모두 해당되는 경우에 적합
    * 버킷 패턴 : 데이터가 일정 기간 동안 스트림으로 유입되는 시계열 데이터에 적합
    * 이상치 패턴 : 도큐먼트의 쿼리가 애플리케이션의 정상적인 패턴을 벗어날 때 사용
    * 계산된 패턴 : 데이터를 자주 계산해야 할 때나 데이터 접근 패턴이 읽기 집약적일 때 사용
    * 서브셋 패턴 : 장비의 램 용량을 초과하는 작업 셋이 있을 때 사용
    * 확장된 참조 패턴 : 각각 고유한 컬렉션이 있는 여러 논리 엔티티가 있고 특정 기능을 위해 엔티티들을 모을 때 사용
    * 근사 패턴 : 리소스가 많이 드는 계산이 필요하지만 높은 정확도가 반드시 필요하지 않은 상황에서 유용
    * 트리 패턴 : 쿼리가 많고 구조적으로 주로 계층적인 데이터가 있을 때 적용
    * 사전 할당 패턴 : 빈 구조를 사전 할당. 예약 정보를 관리하는 시스템 등
    * 도큐먼트 버전 관리 패턴 : 이전 버전을 유지하는 메커니즘 제공

## 9.2 정규화 vs 비정규화
* 정규화는 컬렉션 간의 참조를 이용해 데이터를 여러 컬렉션으로 나누는 작업
* 비정규화는 모든 데이터를 하나의 도큐먼트에 내장하는 것
* 정규화는 쓰기를 빠르게 만들고, 비정규화는 읽기를 빠르게 만듬
* 도큐먼트 내장 방식이 좋은 경우
    - 작은 서브도큐먼트
    - 주기적으로 변하지 않는 데이터
    - 결과적인 일관성이 허용될 때
    - 증가량이 적은 도큐먼트
    - 두 번째 쿼리를 수생하는 데 자주 필요한 데이터
    - 빠른 읽기
* 도큐먼트 참조 방식이 좋은 경우
    - 큰 서브도큐먼트
    - 자주 변하는 데이터
    - 즉각적인 일관성이 필요할 때
    - 증가량이 많은 도큐먼트
    - 결과에서 자주 제외되는 데이터
    - 빠른 쓰기

## 9.3 데이터 조작을 위한 최적화
* 애플리케이션을 최적화하려면 읽기와 쓰기 성능을 분석해 어느 것이 병목 현상을 일으키는지 우선적으로 알아야 한다.
* 읽기 최적화는 인덱스를 사용해 하나의 도큐먼트에서 가능한 한 많은 정보를 반환하는 것과 관련
* 쓰기 최적화는 인덱스 개수를 최소화하고 갱신을 효율적으로 수행하는 것과 관련

### 9.3.1 오래된 데이터 제거
* 어떤 데이터는 짧은 시간 동안만 중요. 몇 주 or 몇 달 후에 이 데이터는 저장 공간만 낭비하게 됨
* 오래된 데이터를 제거하는 세 가지 방법
    - 제한 컬렉션
    - TTL 컬렉션
    - 주기마다 컬렉션 삭제

## 9.4 데이터베이스와 컬렉션 구상
* 일반적으로 스키마가 유사한 도큐먼트는 같은 컬렉션에 보관
* 컬렉셔에서는 락과 저장을 중요하게 고려. 데이터베이스를 각자의 디렉터리에 있게 하고 서로 다른 데이터베이스를 서로 다른 볼륨에 마운트 할 수 있다
* 구성 요소를 중요도에 따라 여러 개의 데이터베이스로 나누고 각각 다른 볼륨 정책을 가지도록 할 수 있다

## 9.5 일관성 관리
* 서버는 각 연결에 대한 요청 큐를 보관
* ㅈ신의 쓰기를 항상 읽을 수 있다
* 각 연결은 데이터베이스에 대해 일관적인 관점을 가짐
* 몽고DB는 읽을 데이터의 일관성과 격리 속성을 제어하는 readConcern 옵션 제공
    - local
    - available
    - majority : read staleness 방지
    - linearizable
    - snapshot

## 9.6 스키마 마이그레이션
* 몽고 DB는 시스템에 많은 부하를 주는 마이그레이션을 피하기 위해 동적 스키마를 갖도록 허용
* 몽고 DB는 이러한 마이그레이션을 지원하는 트랜잭션 지원

## 9.8 몽고DB를 사용하지 않는 경우
* 다양한 유형의 데이터를 여러 차원에 걸쳐 조인하는 작업
* 몽고DB를 지원하지 않는 도구를 사용할 때


# Chapter 10 복제 셋 설정

## 10.1 복제 소개
* 복제는 데이터의 동일한 복사본을 여러 서버상에 보관하는 방법
* 한 대 또는 그 이상의 서버에 이상이 발생하더라도, 복제는 애플리케이션이 정상적으로 동작하게 하고 데이터를 안전하게 보존
* 몽고DB는 복제 셋을 생성함으로써 복제를 설정할 수 있음
* 복제 셋 구성
    - 클라이언트 요청을 처리하는 `프라이머리` 한 대
    - `프라이머리` 데이터의 복사본을 갖는 `세컨더리` 서버 여러 대
* 프라이머리 서버에 장애가 발생하면 세컨더리 서버는 자신들 중에서 새로운 프라이머리 서버를 선출

## 10.2 복제 셋 설정 - 1장
* 단일 장비에 3-노드 복제 셋을 설정하는 방법을 학습


# Chapter 18 애플리케이션 작업 확ㅣ
* 몽고DB가 실행 중인 쿼리의 종류 및 사용하는 데이터 양과 실제로 무엇을 하고 있는지 알아내는 방법

## 18.1 현재 작업 확인
* 실행 중인 작업을 확인하면 느린 작업을 쉽게 찾아낼 수 있다
* `db.currentOp()`: 실행 중인 작업 확인
    * opid : 작업의 고유 식별자
    * active : 작업이 실행 중인지 아닌지 나타냄
    * secs_running : 작업의 실행 기간을 초 단위로 보여줌
    * microsecs_running : 마이크로초 단위로 보여줌
    * op : 작업의 타입. [query | insert | update | remove]
    * desc : 클라이언트 식별자
    * locks : 작업으로 인해 획득한 락 타입을 설명
    * waitingForLock : 작업이 락을 획득하려고 기다리는 중인지 나타냄
    * numYields : 다른 작업의 실행을 위해 락을 해제하고 우위를 양보한 횟수
    * lockstats.timeAcquiringMicros : 작업하는 데 필요한 락을 획득하는 데 걸린 시간
* `db.currentOP()` 함수에도 특정 필드를 기준으로 쿼리 가능

### 18.1.1 문제 있는 작업 찾기
* `db.currentOp()`는 주로 느린 작업을 찾아내는 용도로 사용

### 18.1.2 작업 강제 종료하기
* `db.killOp()`에 해당 작업의 opid를 넘겨줘서 강제 종료할 수 있다.
* 락을 갖거나 기다리는 작업은 강제 종료 불가능

### 18.1.3 거짓 양성
* 사용자 설정에 따라 몽고DB가 몇몇 장기 실행 요청을 실행할 수도 있음
    - 복제 스레드
    - 샤딩에 대한 라이트백 리스너

### 18.1.4 유령(phantom) 작업 방치하기
* 컬렉션에 데이터를 대량으로 로드하면 몽고DB 특유의 이상한 문제점에 맞닥뜨릴 수 있음
* 방지하기 위해 확인 쓰기(acknowledged write) 사용

## 18.2 시스템 프로파일러 사용
* 오래 걸리는 작업에 대한 많은 정보를 제공
* 몽고의 전반적인 성능을 느려지게 함
* db.setProfileingLevel()을 실행해 프로파일러를 켬
* 프로파일링 레벨이 2면 모든 것을 프로파일링 함
* 데이터베이스에서 받은 모든 읽기와 쓰기 요청은 현재 데이터베이스의 system.profile 컬렉션에 기록
* 프로파일링 레벨이 1이면 100ms보다 오래 걸리는 작업을 프로파일링 함
* 프로파일링을 끄려면 레벨 0으로 설정

## 18.3 크기 계산
* 적절한 양의 디스크와 메모리를 제공하려면 도큐먼트, 인덱스, 컬렉션, 데이터베이스가 공간을 얼마나 차지하는지 알아야 함

### 18.3.1 도큐먼트
* `object.bsonsize()`: 도큐먼트 크기를 구하는 가장 쉬운 방법
* 패딩이나 인덱스는 계산하지 않음

### 18.3.2 컬렉션
* `stats(unit)`: 전체 컬렉션에 대한 정보를 확인
    * ns: 네임스페이스
    * size: 각 요소에 대해 Object.bsonsize()를 호출해서 모든 크기를 합한 결과
    * count: 도큐먼트 개수
    * avgObjSize * count == size
    * storageSize: 압축으로 절약된 공간을 반영. size보다 작을 수 있음
    * nindexes: 컬렉션에 있는 인덱스 수

### 18.3.3 데이터베이스
* stats: 데이터베이스에 대한 정보 확인
    * object : 데이터베이스 내 모든 컬렉션에 있는 모든 도큐먼트의 수
    * fsTotalSize : 몽고DB 인스턴스가 데이터를 저장하는 파일시스템의 총 디스크 용량 크기
    * fsUsedSize : 현재 몽고DB가 해당 파일시스템에서 사용하는 총 공간을 나타냄
    * dataSize : 데이터베이스에 보관된 압축되지 않은 데이터의 크기
    * indexSize : 데이터베이스의 모든 인덱스가 차지하는 공간의 양

## 18.4 mongotop과 mongostat 사용
* mongotop은 유닉스의 top 유틸리티와 유사. 어떤 컬렉션이 가장 분주한지에 대한 개요를 제공
* mongotop --locks : 각 데이터베이스의 락에 대한 통계 정보를 얻을 수 있음
* mongostat은 서버 차원의 정보를 제공
    - insert/query/update/delete/getmore/command : 각 작업이 발생한 횟수
    - flushes : 데이터를 디스크에 플러시 한 횟수
    - mapped : 매핑한 메모리의 양. 일반적으로 데이터 디렉터리의 크기
    - vsize : 가상 메모리의 양. 일반적으로 데이터 디렉터리의 두 배 크기
    - res : 메모리 양. 일반적으로 장비의 총 메모리에 최대한 근접
    - locked d : 마지막 타임슬라이스에 락이 걸린 채 대부분의 시간을 소비한 데이터베이스를 보여줌
    - idx miss % : 페이지 폴트를 해야 했던 인덱스 접근 비율
    - qr|qw : 읽기 및 쓰기용 큐의 크기
    - ar|aw : 읽기와 쓰기를 수행하는 현재 활동 중인 클라이언트 수
    - netIn : 몽고DB에 의해 집계된 바이트 단위 네트워크 유입량
    - netOut : 몽고DB에 의해 집계된 바이트 단위 네트워크 유출량
    - conn : 서버가 열어놓은 연결의 개수
    - time : 통계가 찍힌 시간
    
# Chapter 19 몽고DB 보안 소개
* 몽고DB 클러스터와 몽고DB 클러스터가 보유한 데이터를 보호하려면 아래 보안 조치를 사용
    - 권한 활성화와 인증 적용
    - 통신 암호화
    - 데이터 암호화

## 19.1 몽고DB 인증과 권한
* 인증은 사용자의 신원을 확인하는 용도로 사용
* 권한은 확인된 사용자의 리소스와 작업에 대한 접근을 결정

## 19.1.1 인증 메커니즘
* 몽고DB 클러스터에서 권한을 활성화하면, 인증이 적용되고 사용자는 역할에 따라 권한이 부여된 작업만 수행
* 몽고DB 커뮤니티 버전은 SCRAM과 x.509 인증서 인증을 지원
* x.509 디지털 인증서는 널리 사용되는 x.509 공개 키 기반 표준을 사용해 공개 키가 제출자의 것인지 검증

## 19.1.2 권한
* 몽고DB에 사용자를 추가할 때는 특정 데이터베이스에 사용자를 생성해야 한다. 이는 사용자의 인증 데이터베이스이다. 어느 데이터베이스든 이 용도로 사용 가능
* 사용자명과 인증 데이터베이스는 사용자의 고유 식별자 역할을 함
* 사용자의 권한은 인증 데이터베이스에 국한되지 않음
* 사용자를 생성할 때 사용자가 접근 권한을 가져야하는 작업을 지정
* 리소스는 클러스터, 데이터베이스, 컬렉션을 포함
* 내장된 역할
    - read : 모든 비시스템 컬렉션 및 system.indexes, system.js, system.namespace와 같은 시스템 컬렉션의 데이터를 읽음
    - readWirte : read와 동일한 권한과 모든 비시스템 컬렉션 및 system.js 컬렉션의 데이터를 수정할 수 있음
    - dbAdmin : 스키마 관련 작업, 인덱싱, 통계 수집과 같은 관리 작업을 수행
    - userAdmin : 현재 데이터베이스에서 역할과 사용자를 생성하고 수정
    - dbOwner : readWrite, dbAdmin, userAdmin 역할이 부여한 권한을 결합
    - clusterManager : 클러스터상에서 관리와 모니터링 작업을 수행
    - clusterMonitor : 몽고DB 클라우드 매니저와 옵스 매니저 모니터링 에이전트 같은 모니터링 도구에 대한 읽기 전용 접근을 제공
    - hostManage : 서버를 모니터링하고 관리
    - clusterAdmin : clusterManager + clusterMonitor + hostManager + dropDatabase
    - backup : 몽고DB 클라우드 매니저 백업 에이전트 혹은 옵스 매니저 백업 에이전트를 사용하는 권한
    - restore : system.profile 컬렉션 데이터를 포함하지 않는 백업으로부터 데이터를 복원하는 데 필요한 권한을 제공
    - readAnyDatabase : local과 config를 제외한 모든 데이터베이스에서 read와 동일한 권한과 더불어 클러스터 전체에 대한 listDatabases 작업 제공
    - readWriteAndDatabase : local과 config를 제외한 모든 데이터베이스에서 readWrite와 동일한 권한과 더불어 클러스터 전체에 대한 listDatabases 작업 제공
    - userAdminAndDatabase : local과 config를 제외한 모든 데이터베이스에서 userAdmin과 동일한 권한과 더불어 클러스터 전체에 대한 listDatabases 작업 제공
    - dbAdminAndDatabase : local과 config를 제외한 모든 데이터베이스에서 dbAdmin과 동일한 권한과 더불어 클러스터 전체에 대한 listDatabases 작업 제공
    - root : 모든 권한
* 사용자 정의 역할을 만들 수도 있음

### 19.1.3 멤버와 클라이언트를 인증하기 위해 x.509 인증서 사용하기
* 클러스터를 보호하려면 클러스터 내에서 통신하는 모든 서비스가 서로 인증해야 함

* x.509의 경우 신뢰할 수 있는 인증기관(CA)이 모든 인증서에 서명해야 한다
* 서명은 인증서의 명명된 소유자(subject)가 해당 인증서와 연결된 공개 키를 소유함을 인증
* CA는 중간자 공격을 방지하는 신뢰할 수 있는 제3자 역할을 함

* 각 클러스터 멤버와 클라이언트는 CA에서 서명한 자체 인증서가 있음
* 몽고DB 배포는 단일 인증 기관에서 생성하고 서명한 유효한 인증서를 사용해야 한다
* 몽고DB에서 x.509 인증과 함께 사용하려면 멤버 인증서에 아래 속성이 있어야 함
    - 단일 CA는 클러스터 멤버에 대해 모든 x.509 인증서를 발급해야 함
    - 멤버 인증서의 제모에 있는 고유 이름(DN, Distinguished Name)은 조직(O, Organization), 조직 단위(OU, Organization Unit), 도메인 구성 요소(DC, Domain Component) 속성 중 적어도 하나에 비어있지 않은 값을 지정해야 함
    - O, OU, DC 속성은 다른 클러스터 멤버에 대한 인증서의 속성과 일치해야 함
    - 일반 이름(CN, Common Name) 혹은 소유자 대체 이름(Subject Alternative Name)은 다른 클러스터 멤버가 사용하는 서버의 호스트명과 일치해야 함


