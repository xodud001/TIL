# Chapter 1 몽고DB 소개
* 몽고 DB는 강력하고 유연하며 확장성 높은 범용 데이터베이스이다
* 보조 인덱스, 범위 쿼리, 정렬, 집계, 공간 정보 인덱스 등을 확장 기능과 결합

## 1.1 손쉬운 사용
* 몽고 DB는 `도큐먼트 지향` 데이터베이스다
* 분산 확장을 쉽게 하기 위함
* 행 개념 대신에 보다 유연한 모델인 도큐먼트를 사용
* 내장 도큐먼트와 배열을 허용함으로써 도큐먼트 지향 모델은 복잡한 계층 관계를 하나의 레코드로 표현
* 고정된 스키마가 없음. 필요 시 쉽게 필드를 추가하거나 제거할 수 있음

## 1.2 확장 가능한 설계
* 저장할 데이터가 증가함에 따라, 데이터베이스를 어떻게 확장할 것인가와 같은 어려운 의사 결정을 해야 하는 상황에 직면함
* 스케일 업 or 스케일 아웃 중 선택해야 함
    * 스케일 업은 단순하고 쉽지만 비싸고 물리적인 한계가 있음
    * 스케일 아웃은 경제적이고 확장이 용이함. 하지만 관리가 어려움
* 몽고DB는 분산 확장을 염두에 두고 설계
* 기존에 배포된 애플리케이션의 토폴로지를 변경할 때도 애플리케이션 로직은 그대로 유지 가능

## 1.3 다양한 기능
* 몽고 DB는 CRDU 외에도 DBMS의 대부분의 기능과 더불아 아래 기능들을 제공
* 인덱싱
    * 일반적으로 보조 인덱스를 지원
    * 고유, 복합, 공간 정보, 전문 인덱싱 기능도 제공
* 집계
    * 데이터 처리 파이프라인 개념을 기반으로 한 집계 프레임워크를 제공
* 특수한 컬렉션 유형
    * 특정 시간에 만료해야 하는 데이터에 대해 유효 시간(TTL) 지원
    * 기준 필터와 일치하는 도큐먼트에 한정된 부분 인덱스 지원
* 파일 스토리지
    * 큰 파일과 파일 메타데이터를 편리하게 저장하는 프로토콜을 지원
* RDB에 사용되는 일부 기능, 특히 복잡한 조인은 존재하지 않음

## 1.4 고성능
* 몽고 DB에서는 동시성과 처리량을 극대화하기 위해 와이어드타이거 스토리지 엔진에 기회적 락을 사용

# Chapter 2 몽고DB 기본
* 몽고 DB 데이터의 기본 단위는 도큐먼트이며, RDB의 행과 유사
* 같은 맥락에서 컬렉션은 동적 스키마가 있는 테이블과 같음
* 몽고 DB의 단일 인스턴스는 자체적인 컬렉션을 갖는 여러 개의 독립적인 데이터베이스를 호스팅
* 모든 도큐먼트는 컬렉션 내에서 고유한 특수키인 "_id"를 가짐
* 몽고 DB는 몽고 셸이라는 도구와 함께 배포

## 2.1 도큐먼트
* 도큐먼트 : 정렬된 키와 연결된 값의 집합
* 도큐먼트 표현 방식 : 맵, 해시, 딕셔너리 같은 자료구조
* 도큐먼트의 키는 문자열. 아래를 제외한 UTF-8이면 가능
    * \0(null) 미포함, \0은 키의 끝을 나타내는 데 사용
    * .과 $는 예약어
* 데이터형과 대소문자를 구분
* 키가 중복될 수 없음

## 2.2 컬렉션
* 도큐먼트의 모음
* 도큐먼트가 행에 대응된다면 컬렉션은 테이블에 대응

### 2.2.1 동적 스키마
* 컬렉션은 동적 스키마를 가짐
* 하나의 컬렉션 내 도큐먼트들이 모두 다른 구조를 가질 수 있다
* 도큐먼트들의 키, 키의 개수, 데이터형의 값은 모두 다름
* 다른 구조의 도큐먼트라도 같은 컬렉션에 저장하면 안되는 이유
    * 같은 컬렉션에 다른 종류의 도큐먼트를 저장하면 개발자와 관리자에게 번거로움
    * 컬렌션별로 목록을 뽑으면 빠름
    * 같은 종류의 데이터를 하나의 컬렉션에 모아두면 데이터 지역성에 좋다
    * 인덱스를 만들면 도큐먼트는 특정 구조를 가져야 함

### 2.2.2 네이밍
* 컬렉션은 이름으로 식별
* 어떤 UTF-8 문자든 쓸 수 있지만 제약 이있음
* 제약
    * 빈 문자열은 안됨
    * \0(null) 안됨
    * system.은 예약어라 안됨
    * $는 예약어라 안됨

**서브 컬렉션**
* 서브컬렉션의 네임스페이스에 .(마침표) 문자를 사용해 컬렉션을 체계화한다.
* 예로 블로그 기능이 있는 애플리케이션은 `blog.posts`와 `blog.authors`라는 컬렉션을 가짐
* 서브컬렉션은 몽고DB의 데이터를 체계화하는 좋은 방법

## 2.3 데이터베이스
* 몽고DB는 데이터베이스에 컬렉션을 그룹지어 놓음
* 몽고 DB의 단일 인스턴스는 여러 데이터베이스를 호스팅 할 수 있음
* 각 데이터베이스를 완전히 독립적으로 취급 가능
* 데이터베이스 이름 규칙
    * 어떤 UTF-8 문자열 가능
    * 빈 문자열 안됨
    * 다음 문자 안됨. /, \, ., ' ', *, <, >, :, |, ?, $, (single space), \0(null)
    * 대소문자 구별
    * 최대 64바이트
* 직접 접근할 수 있지만 예약된 데이터베이스 이름
    * admin : 인증과 권한 부여 역할
    * local : 단일 서버에 대한 데이터를 저장
    * config : 샤딩된 몽고DB 클러스터는 config 데이터베이스를 샤용해 각 샤드의 정보를 저장

## 2.4 몽고DB 시작
* 서버를 시작하려면 유닉스 명령행 환경에서 mongod 실행 파일 실행
* mongod는 인수 없이 실행하면 기본 데이터 디렉터리로 /data/db를 사용
* 데이터 디렉터리가 없거나 쓰기 권한이 없을 때는 서버가 시작되지 않음
* 기본 포트는 27017
* mongod 서버를 실행한 셸에서 `Ctrl` + `C`를 누르면 graceful down 됨

* brew를 이용한 Mongo DB 설치 및 실행, 종료
```
brew tap mongodb/brew
brew update
brew install mongodb-community@5.0
//자동
brew services start mongodb-community@5.0
brew services stop mongodb-community@5.0

//수동 - Apple M1
mongod --config /opt/homebrew/etc/mongod.conf --fork
```
## 2.5 몽고DB 셸 소개
* 몽고DB는 명령행에서 몽고DB 인스턴스와 상호작용하는 자바스크립트 셸을 제공

### 2.5.1 셸 실행
* 책에는 mongo를 실행하면 된다 하는데 6버전 부터는 mongosh 인듯
* 셸은 완전한 자바스크립트 해석기임

### 2.5.2 몽고DB 클라이언트
* 셸은 독자적으로 쓸 수 있는 몽고DB 클라이언트
* 셸은 시작할 때 몽고DB 서버의 test 데이터베이스에 연결. 데이터베이스 연결을 전역 변수 db에 할당
```
> db
test
```
* 데이터베이스 선택 작업
```
> use video
switched to db video
>db
video
```
* 자바스크립트 셸이므로 변수 이름을 입력하면 표현식으로 평가.
* 아래와 같이 DB 변수에서 컬렉션에 접근
```
> db.movies
```

### 2.5.3 셸 기본 작업
* 셸에서 데이터를 조작하거나 보려면 CRUD의 네 가지 기본적인 작업을 함

**생성, Create**
* `insertOne` 함수는 컬렉션에 도큐먼트를 추가
* 영화를 저장한다고 가정
    * movie라는 지역 변수를 생성하고 객체를 할당
    ```
    movie = {"title":"연가시", "director":"봉준호","year":2018}
    ```
    * 위 객체를 `insertOne` 함수를 이용해서 movies 컬렉션에 저장
    ```
    > db.movies.insertOne(movie)
    ```
    * 데이터베이스에 저장된 컬렉션에서 find를 호출해서 확인
    ```
    > db.movies.find().pretty()
    ```

**읽기, Read**
* `find`와 `findOne`은 컬렉션을 쿼리하는 데 사용
* 컬렉션에서 단일 도큐먼트 읽기
```
> db.movies.findOne()
```
* `find`와 `findOne`은 `쿼리 도큐먼트` 형태로 조건 전달도 가능

**갱신, Update**
* 게시물을 갱신하려면 `updateOne`을 사용. 최소 2개의 매개변수 필요
* 첫 번째는 수정할 도큐먼트를  찾는 기준, 두 번째는 갱신 작업을 설명하는 도큐먼트
* 앞서 만든 영화에서 리뷰 기능을 사용하기로 결정했다 가정
```
> db.movies.updateOne({title: "연가시"}, {$set: {revies:[]}})
```

**삭제, Delete**
* deleteOne과 deleteMany는 도큐먼트를 데이터베이스에서 영구적으로 삭제
* 두 함수 모두 필터 도큐먼트로 삭제 조건을 지정
```
> db.movies.deleteOne({title: "연가시"})
```
* 필터와 일치하는 모든 도큐먼트를 삭제하려면 deleteMayn 사용

## 2.6 데이터 형
* 몽고DB는 도큐먼트의 값으로 다양한 데이터형을 지원

### 2.6.1 기본 데이터형
* 몽고DB에서 도큐먼트는 자바스크립트 객체와 개념적으로 닮았다는 점에서 JSON과 닮았다라고 생각할 수 있음
* 몽고DB는 JSON의 키/값 쌍 성질을 유지하면서 추가적인 데이터형을 지원
* null : null값과 존재하지 않는 필드를 표현
```json
{"x": null}
```
* 불리언 : 참과 거짓 값에 사용
```json
{"x": true}
```
* 숫자 : 셸은 64비트 부동소수점 수를 기본으로 사용
```json
{"x": 3}
{"x": 3.14}
```
* 4바이트 혹은 8바이트의 부호 정수는 각각 NumberInt 혹은 NumberLong 클래스 사용
```json
{"x": NumberInt("3")}
{"x": NumberLong("3")}
```
* 문자열 : 어떤 UTF-8 문자열이든 문자열형으로 표현할 수 있다
```json
{"x": "foobar"}
```
* 날짜 : 몽고 DB는 1970년 1월 1일부터의 시간을 1/1000초 단위로 나타내는 64비트 정수로 날짜를 저장
```json
{"x": new Date()}
```
* 정규 표현식 : 쿼리는 자바스크립트의 정규 표현식 문법을 사용할 수 있음
```json
{"x": /foobar/i}
```
* 배열 : 값의 셋이나 리스트를 배열로 표현할 수 있다
```json
{"x": ["a","b","c"]}
```
* 내장 도큐먼트 : 도큐먼트는 부모 도큐먼트의 값으로 내장된 도큐먼트 전체를 포함 할 수 있음
```json
{"x": {"foo":"bar"}}
```
* 객체 ID : 객체 ID는 도큐먼트용 12바이트 ID
```json
{"x": ObjectId()}
```
* 이진 데이터 : 임의의 바이트 문자열. 셸에서 조작 불가능
* 코드 : 임의의 자바스크림트 코드를 포함할 수 있음
```json
{"x": function() { /* ... */}}
```

### 2.6.2 날짜
* 자바스크립트에서 Date 클래스는 몽고 DB의 날짜를 표현하는데 사용
* 새로운 데이트 객체를 생성할 때는 항상 `new Date()` 호출

### 2.6.3 배열
* 배열은 서로 다른 데이터형을 값으로 포함할 수 있음
```json
{"things":["pie", 3.14]}
```
* 배열에 쿼리하거나 배열의 내용을 이용해 인덱스를 만들 수 있다

### 2.6.4 내장 도큐먼트
* 키에 대한 값이 되는 도큐먼트를 내장 도큐먼트라 함
```json
{
    "name": "John Doe",
    "address":{
        "street": "123 Park Street",
        "city": "Anytown",
        "state": "NY"
    }
}
```
* 몽고 DB는 내장 도큐먼트의 구조를 이해하고 인덱스를 구성하고 쿼리하며, 갱신하기 위해 내장 도큐먼트 내부에 접근
* 관계형 DB에는 이가 분리된 두 개의 행으로 모델링 됨
* 몽고DB에서는 많은 데이터 반복이 생길 수 있음

### 2.6.5 _id와 ObjectId
* 몽고DB에 저장된 모든 도큐먼트는 "_id" 키를 가진다
* "_id" 키 값은 어떤 데이터형이여도 상관없지만 "ObjectId"가 기본
* 하나의 컬렉션에서 모든 도큐먼트는 고유한 "_id" 값을 가짐

**ObjectIds**
* ObjectId는 "_id"의 기본 데이터형
* ObjectId 클래스는 가벼우면서, 여러 장비에 걸쳐 전역적으로 고유하게 생성하기 쉽게 설계
* 몽고DB는 분산 데이터베이스로 설계됐기 때문에 샤딩된 환경에서 고유 식별자를 생성하는 것이 매우 중요
* ObjectId는 12바이트 스토리지를 이용. 24자리 16진수 문자열 표현이 가능. 바이트당 2자리를 사용
* 여러 개의 새로운 ObjectID를 연속으로 생성하면 매번 마지막 숫자 몇 개만 바뀜
* 몇 초 간격을 두고 생성하면 ObjectID의 중간 숫자 몇 개가 바뀜
* 도큐먼트를 입력할 때 "_id" 키를 명시하지 않으면 입력된 도큐먼트에 키가 자동으로 추가

## 2.7 몽고DB 셸 사용
* 원격 몽고 서버 접속
```
mongosh some-host:port/db
```
* mongod에 연결하지 않고 시작하기
```
mongosh --nodb
conn = new Mongo("some-host:port")
db = conn.getDB("test")
```

## 2.7.1 셸 활용 팁
* mongosh는 단순하게 보면 자바스크립트 셸이므로 자바스크립트 문서 참조해도 됨
* help 입력하면 셸에 내장된 도움말 볼 수 있음
* 데이터베이스 수준의 도움말은 db.help()
* 컬렉션 수준의 도움말은 db.foo.help()
* 함수의 기능을 알고 싶으면 함수명을 괄호없이 입력하면 됨
* 함수의 시그니처는 함수명.help로 확인 가능

## 2.7.2 셸에서 스크립트 실행하기
* 자바 스크립트 파일을 셸로 전달해 실행 가능
```m
mongosh script.js
```
* load 함수를 사용해서 대화형 셸에서 스크립트를 실행할 수 있음
```m
> load('script.js')
```
* 스크립트는 db 변수에 대한 접근은 가능하지만 use db나 show collections와 같은 셸 보조자는 작동하지않음

# Chapter 3 도큐먼트 생성, 갱신, 삭제

## 3.1 도큐먼트 삽입
* 삽입은 몽고DB에 데이터를 추가하는 기본 방법
* 컬렉션의 insertOne 메서드 사용
```m
db.movies.insertOne({"title": "Batman"})
```
* 도큐먼트에 "_id" 키가 자동으로 추가

### 3.1.1 insertMany
* 여러 도큐먼트를 컬렉션에 삽입하려면 insertMany로 도큐먼트 배열을 전달
```m
db.movies.insertMany(
    [
        {"title":"Iron Man"},
        {"title":"Batman"},
        {"title":"Hulk"}
    ]
)
```
* 몽고DB의 버전에 따라 메시지의 용량에 제한이 있으므로 한 번에 일괄 삽입 할 수 있는 크기에 제한이 있다. 
* 제한된 용량보다 크면 드라이버가 여러 개로 분할
* 삽입시에 정렬 or 비정렬을 선택할 수 있다. 기본값은 정렬
* 정렬 삽입시에 중간에 에러 발생하면 해당 발생 지점부터 멈춤
* 비정렬 삽입시에 중간에 에러 발생하면 해당 도큐먼트 제외하고 다 삽입 시도

### 3.1.2 삽입 유효성 검사
* 몽고 DB는 삽입된 데이터에 최소한의 검사를 수행
* 도큐먼트의 기본 구조를 검사해 "_id" 필드가 존재하지 않으면 추가하고, 모든 도큐먼트는 16메가바이트보다 작아야 하므로 크기 검사를 함
    * [MongoDB 6.0](https://www.mongodb.com/docs/manual/core/document/) 기준으로 아직 16 megabyte. 600쪽 짜리 책이 3MB 정도 함
* 도큐먼트의 Binary JSON(BSON) 크기를 보려면 셸에서 object.bsonsize(doc)를 실행
* [MongoDB 6.0](https://www.mongodb.com/docs/v6.0/reference/operator/aggregation/bsonSize/?_ga=2.178847844.1309917206.1662172054-1070121506.1661954868&_gac=1.222154986.1662172054.Cj0KCQjw08aYBhDlARIsAA_gb0f7LPQVKS-MrGyglm8EGGAAKebt9V5XPTbslA_4WUHoHt0I31dwMA0aAj7REALw_wcB)에서 bsonsize 보는 방법

### 3.1.3 삽입
* 몽고DB 3.0 이전 버전에서는 삽입 할 때 insert 사용
* 호환성 지원 때문에 사용 할 수는 있지만 insertOne or insertMany를 사용

## 3.2 도큐먼트 삭제
* deleteOne과 deleteMany를 이용해서 삭제 가능
```m
db.movies.deleteOne({"_id": ObjectId("6312b034452fd87b69e1978c")})
```
* deleteOne은 필터에 의해 여러개가 걸리면 첫 번째 도큐먼트만 삭제
* deleteMany는 필더에 걸린거 전부 삭제
* 몽고DB 3.0 이전 버전에서는 삭제할 때 remove 사용
* 호환성 지원 때문에 사용 할 수는 있지만 deleteOne or deleteMany를 사용

### 3.2.1 drop
* deleteMany를 사용해 컬렉션의 모든 도큐먼트 삭제
* 전체 컬렉션을 삭제하려면 drop을 사용하는 편이 더 빠름
```m
db.movies.drop()
```

## 3.3 도큐먼트 갱신
* 도큐먼트는 updateOne, updateMany, replaceOne과 같은 갱신 메서드를 사용해 변경
* updateOne과 updateMany는 필터 도큐먼트를 첫 번째 매개변수로, 변경 사항을 설정하는 수정자 도큐먼트를 두 번째 매개변수로 사용
* replaceOne도 첫 번째 매개변수로 필터를 사용하지만 두 번째 매개변수는 필터와 일치하는 도큐먼트를 교체할 도큐먼트
* 갱신은 원자적으로 이뤄짐. 두 개의 갱신이 동시에 발생하면 서버에 먼저 도착한 요청이 적용된 후 다음 요청이 적용

### 3.3.1 도큐먼트 치환
* replaceOne은 도큐먼트를 새로운 것으로 완전히 치환함
* replaceOne의 필터에 2개 이상의 도큐먼트가 걸리면 갱신 실패. 고유한 값으로 시도해야됨
* "_id" 값이 컬렉션 기본 인덱스의 기초를 형성하므로 필터에 "_id"를 사용해도 효율적이다

### 3.3.2 갱신 연산자
* 부분 갱신에는 원자적 갱신 연산자를 사용
* 갱신 연산자는 키를 변경, 추가, 제거하고 배열과 내장 도큐먼트를 조작하는 복잡한 갱신 연산을 지정하는 데 사용하는 특수키다

**`$Set` 제한자 사용하기**
* `$Set`은 필드 값을 설정.
* 필드가 존재하지 않으면 새 필드 생성
```m
db.movies.updateOne(
    {"title":"Iron Man"}, 
    {
        "$set": {
            "description":"Beeem!"
        }
    }
)
```

**증가와 감소**
* `$inc` 연산자는 이미 존재하는 키의 값을 변경하거나 새 키를 생성하는 데 사용.
* 키 값은 무조건 숫자여야 함
```m
db.movies.updateOne(
    {"title":"Iron Man"}, 
    {"$inc": {"score":50}}
)
```

**배열 연산자**
* 요소 추가하기 : `$push`는 배열이 이미 존재하면 배열 끝에 요소를 추가하고, 존재하지 않으면 새로운 배열을 생성
```m
db.movies.updateOne(
    {"title":"Iron Man"}, 
    {"$push": {"actors": "toni"}}
)
```
* `$push`에 `$each` 제한자를 사용하면 작업 한 번으로 값을 여러 개 추가할 수 있음
```m
db.movies.updateOne(
    {"title":"Iron Man"}, 
    {"$push": {"actors":{"$each": ["toni", "stark"]}}}
)
```
* `$slice`를 이용해서 도큐먼트 내에 큐를 생성해 top N 목록을 만들 수 있음
```m
db.movies.updateOne(
    {"title":"Iron Man"}, 
    {"$push": {"actors":{"$each": ["toni", "stark"],
                    "$slice": -10}}}
)
```
* `$sort`를 이용해서 정렬된 상태로 추가할 수 있음
* 1 : 오름차순
* -1 : 내림차순
```m
db.movies.updateOne(
    {"title":"Iron Man"}, 
    {
        "$push": {
            "actors":
            {
                "$each": [{"name":"toni", "age":30}, 
                            {"name":"startk", "age":40}],
                "$slice": -10,
                "$sort": {"age": -1}
            }
        }
    }
)
```
* 배열을 집합으로 사용하기
* `$ne`를 사용하면 값을 추가하면서 중복을 제거
```m
db.movies.updateOne({"actors": {"$ne": "toni"}}, {"$push": {"actors": {"name":"Jone", "age": 20}}})
```
* `$addToSet`을 사용하면 `$ne`가 작동하지 않을 때나 무슨 일이 얼아났는지 더 잘 알수 있을 때 유용
* `$addToSet`을 사용하면 배열에 중복을 피할 수 있음
```m
db.movies.updateOne({"_id":ObjectId("6312b034452fd87b69e1978d")}, {"$addToSet": {"actors": {"name":"Jone", "age": 20}}})
```
* `$pop`: 배열에서 요소 제거하기
    * {"$pop":{"key":1}} : 배열의 마지막 요소부터 제거
    * {"$pop":{"key":-1}} : 배열의 첫 요소부터 제거
* `$pull`: 주어진 조건에 맞는 배열 요소를 모두 제거
```
db.lists.insertOne({"todo":["dishes", "laundry", "dry cleaning"]})
db.lists.updateOne({}, {"$pull":{"todo":"laundry"}})
```
**배열의 위치 기반 변경**
* 위치를 이용하거나 위치 연산자($)를 사용해서 변경
* 배열 인덱스는 기준이 0
* 배열 요소는 인덱스를 도큐먼트의 키처럼 사용




