# Chapter 1 몽고DB 소개
* 몽고 DB는 강력하고 유연하며 확장성 높은 범용 데이터베이스이다
* 보조 인덱스, 범위 쿼리, 정렬, 집계, 공간 정보 인덱스 등을 확장 기능과 결합

## 1.1 손쉬운 사용
* 몽고 DB는 `도큐먼트 지향` 데이터베이스다
* 분산 확장을 쉽게 하기 위함
* 행 개념 대신에 보다 유연한 모델인 도큐먼트를 사용
* 내장 도큐먼트와 배열을 허용함으로써 도큐먼트 지향 모델은 복잡한 계층 관계를 하나의 레코드로 표현
* 고정된 스키마가 없음. 필요 시 쉽게 필드를 추가하거나 제거할 수 있음

## 1.2 확장 가능한 설계
* 저장할 데이터가 증가함에 따라, 데이터베이스를 어떻게 확장할 것인가와 같은 어려운 의사 결정을 해야 하는 상황에 직면함
* 스케일 업 or 스케일 아웃 중 선택해야 함
    * 스케일 업은 단순하고 쉽지만 비싸고 물리적인 한계가 있음
    * 스케일 아웃은 경제적이고 확장이 용이함. 하지만 관리가 어려움
* 몽고DB는 분산 확장을 염두에 두고 설계
* 기존에 배포된 애플리케이션의 토폴로지를 변경할 때도 애플리케이션 로직은 그대로 유지 가능

## 1.3 다양한 기능
* 몽고 DB는 CRDU 외에도 DBMS의 대부분의 기능과 더불아 아래 기능들을 제공
* 인덱싱
    * 일반적으로 보조 인덱스를 지원
    * 고유, 복합, 공간 정보, 전문 인덱싱 기능도 제공
* 집계
    * 데이터 처리 파이프라인 개념을 기반으로 한 집계 프레임워크를 제공
* 특수한 컬렉션 유형
    * 특정 시간에 만료해야 하는 데이터에 대해 유효 시간(TTL) 지원
    * 기준 필터와 일치하는 도큐먼트에 한정된 부분 인덱스 지원
* 파일 스토리지
    * 큰 파일과 파일 메타데이터를 편리하게 저장하는 프로토콜을 지원
* RDB에 사용되는 일부 기능, 특히 복잡한 조인은 존재하지 않음

## 1.4 고성능
* 몽고 DB에서는 동시성과 처리량을 극대화하기 위해 와이어드타이거 스토리지 엔진에 기회적 락을 사용

# Chapter 2 몽고DB 기본
* 몽고 DB 데이터의 기본 단위는 도큐먼트이며, RDB의 행과 유사
* 같은 맥락에서 컬렉션은 동적 스키마가 있는 테이블과 같음
* 몽고 DB의 단일 인스턴스는 자체적인 컬렉션을 갖는 여러 개의 독립적인 데이터베이스를 호스팅
* 모든 도큐먼트는 컬렉션 내에서 고유한 특수키인 "_id"를 가짐
* 몽고 DB는 몽고 셸이라는 도구와 함께 배포

## 2.1 도큐먼트
* 도큐먼트 : 정렬된 키와 연결된 값의 집합
* 도큐먼트 표현 방식 : 맵, 해시, 딕셔너리 같은 자료구조
* 도큐먼트의 키는 문자열. 아래를 제외한 UTF-8이면 가능
    * \0(null) 미포함, \0은 키의 끝을 나타내는 데 사용
    * .과 $는 예약어
* 데이터형과 대소문자를 구분
* 키가 중복될 수 없음

## 2.2 컬렉션
* 도큐먼트의 모음
* 도큐먼트가 행에 대응된다면 컬렉션은 테이블에 대응

### 2.2.1 동적 스키마
* 컬렉션은 동적 스키마를 가짐
* 하나의 컬렉션 내 도큐먼트들이 모두 다른 구조를 가질 수 있다
* 도큐먼트들의 키, 키의 개수, 데이터형의 값은 모두 다름
* 다른 구조의 도큐먼트라도 같은 컬렉션에 저장하면 안되는 이유
    * 같은 컬렉션에 다른 종류의 도큐먼트를 저장하면 개발자와 관리자에게 번거로움
    * 컬렌션별로 목록을 뽑으면 빠름
    * 같은 종류의 데이터를 하나의 컬렉션에 모아두면 데이터 지역성에 좋다
    * 인덱스를 만들면 도큐먼트는 특정 구조를 가져야 함

### 2.2.2 네이밍
* 컬렉션은 이름으로 식별
* 어떤 UTF-8 문자든 쓸 수 있지만 제약 이있음
* 제약
    * 빈 문자열은 안됨
    * \0(null) 안됨
    * system.은 예약어라 안됨
    * $는 예약어라 안됨

**서브 컬렉션**
* 서브컬렉션의 네임스페이스에 .(마침표) 문자를 사용해 컬렉션을 체계화한다.
* 예로 블로그 기능이 있는 애플리케이션은 `blog.posts`와 `blog.authors`라는 컬렉션을 가짐
* 서브컬렉션은 몽고DB의 데이터를 체계화하는 좋은 방법

## 2.3 데이터베이스
* 몽고DB는 데이터베이스에 컬렉션을 그룹지어 놓음
* 몽고 DB의 단일 인스턴스는 여러 데이터베이스를 호스팅 할 수 있음
* 각 데이터베이스를 완전히 독립적으로 취급 가능
* 데이터베이스 이름 규칙
    * 어떤 UTF-8 문자열 가능
    * 빈 문자열 안됨
    * 다음 문자 안됨. /, \, ., ' ', *, <, >, :, |, ?, $, (single space), \0(null)
    * 대소문자 구별
    * 최대 64바이트
* 직접 접근할 수 있지만 예약된 데이터베이스 이름
    * admin : 인증과 권한 부여 역할
    * local : 단일 서버에 대한 데이터를 저장
    * config : 샤딩된 몽고DB 클러스터는 config 데이터베이스를 샤용해 각 샤드의 정보를 저장

## 2.4 몽고DB 시작
* 서버를 시작하려면 유닉스 명령행 환경에서 mongod 실행 파일 실행
* mongod는 인수 없이 실행하면 기본 데이터 디렉터리로 /data/db를 사용
* 데이터 디렉터리가 없거나 쓰기 권한이 없을 때는 서버가 시작되지 않음
* 기본 포트는 27017
* mongod 서버를 실행한 셸에서 `Ctrl` + `C`를 누르면 graceful down 됨

* brew를 이용한 Mongo DB 설치 및 실행, 종료
```
brew tap mongodb/brew
brew update
brew install mongodb-community@5.0
//자동
brew services start mongodb-community@5.0
brew services stop mongodb-community@5.0

//수동 - Apple M1
mongod --config /opt/homebrew/etc/mongod.conf --fork
```
## 2.5 몽고DB 셸 소개
* 몽고DB는 명령행에서 몽고DB 인스턴스와 상호작용하는 자바스크립트 셸을 제공

### 2.5.1 셸 실행
* 책에는 mongo를 실행하면 된다 하는데 6버전 부터는 mongosh 인듯
* 셸은 완전한 자바스크립트 해석기임

### 2.5.2 몽고DB 클라이언트
* 셸은 독자적으로 쓸 수 있는 몽고DB 클라이언트
* 셸은 시작할 때 몽고DB 서버의 test 데이터베이스에 연결. 데이터베이스 연결을 전역 변수 db에 할당
```
> db
test
```
* 데이터베이스 선택 작업
```
> use video
switched to db video
>db
video
```
* 자바스크립트 셸이므로 변수 이름을 입력하면 표현식으로 평가.
* 아래와 같이 DB 변수에서 컬렉션에 접근
```
> db.movies
```

### 2.5.3 셸 기본 작업
* 셸에서 데이터를 조작하거나 보려면 CRUD의 네 가지 기본적인 작업을 함

**생성, Create**
* `insertOne` 함수는 컬렉션에 도큐먼트를 추가
* 영화를 저장한다고 가정
    * movie라는 지역 변수를 생성하고 객체를 할당
    ```
    movie = {"title":"연가시", "director":"봉준호","year":2018}
    ```
    * 위 객체를 `insertOne` 함수를 이용해서 movies 컬렉션에 저장
    ```
    > db.movies.insertOne(movie)
    ```
    * 데이터베이스에 저장된 컬렉션에서 find를 호출해서 확인
    ```
    > db.movies.find().pretty()
    ```

**읽기, Read**
* `find`와 `findOne`은 컬렉션을 쿼리하는 데 사용
* 컬렉션에서 단일 도큐먼트 읽기
```
> db.movies.findOne()
```
* `find`와 `findOne`은 `쿼리 도큐먼트` 형태로 조건 전달도 가능

**갱신, Update**
* 게시물을 갱신하려면 `updateOne`을 사용. 최소 2개의 매개변수 필요
* 첫 번째는 수정할 도큐먼트를  찾는 기준, 두 번째는 갱신 작업을 설명하는 도큐먼트
* 앞서 만든 영화에서 리뷰 기능을 사용하기로 결정했다 가정
```
> db.movies.updateOne({title: "연가시"}, {$set: {revies:[]}})
```

**삭제, Delete**
* deleteOne과 deleteMany는 도큐먼트를 데이터베이스에서 영구적으로 삭제
* 두 함수 모두 필터 도큐먼트로 삭제 조건을 지정
```
> db.movies.deleteOne({title: "연가시"})
```
* 필터와 일치하는 모든 도큐먼트를 삭제하려면 deleteMayn 사용

## 2.6 데이터 형
* 몽고DB는 도큐먼트의 값으로 다양한 데이터형을 지원

### 2.6.1 기본 데이터형
* 몽고DB에서 도큐먼트는 자바스크립트 객체와 개념적으로 닮았다는 점에서 JSON과 닮았다라고 생각할 수 있음
* 몽고DB는 JSON의 키/값 쌍 성질을 유지하면서 추가적인 데이터형을 지원
* null : null값과 존재하지 않는 필드를 표현
```json
{"x": null}
```
* 불리언 : 참과 거짓 값에 사용
```json
{"x": true}
```
* 숫자 : 셸은 64비트 부동소수점 수를 기본으로 사용
```json
{"x": 3}
{"x": 3.14}
```
* 4바이트 혹은 8바이트의 부호 정수는 각각 NumberInt 혹은 NumberLong 클래스 사용
```json
{"x": NumberInt("3")}
{"x": NumberLong("3")}
```
* 문자열 : 어떤 UTF-8 문자열이든 문자열형으로 표현할 수 있다
```json
{"x": "foobar"}
```
* 날짜 : 몽고 DB는 1970년 1월 1일부터의 시간을 1/1000초 단위로 나타내는 64비트 정수로 날짜를 저장
```json
{"x": new Date()}
```
* 정규 표현식 : 쿼리는 자바스크립트의 정규 표현식 문법을 사용할 수 있음
```json
{"x": /foobar/i}
```
* 배열 : 값의 셋이나 리스트를 배열로 표현할 수 있다
```json
{"x": ["a","b","c"]}
```
* 내장 도큐먼트 : 도큐먼트는 부모 도큐먼트의 값으로 내장된 도큐먼트 전체를 포함 할 수 있음
```json
{"x": {"foo":"bar"}}
```
* 객체 ID : 객체 ID는 도큐먼트용 12바이트 ID
```json
{"x": ObjectId()}
```
* 이진 데이터 : 임의의 바이트 문자열. 셸에서 조작 불가능
* 코드 : 임의의 자바스크림트 코드를 포함할 수 있음
```json
{"x": function() { /* ... */}}
```

### 2.6.2 날짜
* 자바스크립트에서 Date 클래스는 몽고 DB의 날짜를 표현하는데 사용
* 새로운 데이트 객체를 생성할 때는 항상 `new Date()` 호출

### 2.6.3 배열
* 배열은 서로 다른 데이터형을 값으로 포함할 수 있음
```json
{"things":["pie", 3.14]}
```
* 배열에 쿼리하거나 배열의 내용을 이용해 인덱스를 만들 수 있다

### 2.6.4 내장 도큐먼트
* 키에 대한 값이 되는 도큐먼트를 내장 도큐먼트라 함
```json
{
    "name": "John Doe",
    "address":{
        "street": "123 Park Street",
        "city": "Anytown",
        "state": "NY"
    }
}
```
* 몽고 DB는 내장 도큐먼트의 구조를 이해하고 인덱스를 구성하고 쿼리하며, 갱신하기 위해 내장 도큐먼트 내부에 접근
* 관계형 DB에는 이가 분리된 두 개의 행으로 모델링 됨
* 몽고DB에서는 많은 데이터 반복이 생길 수 있음

### 2.6.5 _id와 ObjectId
* 몽고DB에 저장된 모든 도큐먼트는 "_id" 키를 가진다
* "_id" 키 값은 어떤 데이터형이여도 상관없지만 "ObjectId"가 기본
* 하나의 컬렉션에서 모든 도큐먼트는 고유한 "_id" 값을 가짐

**ObjectIds**
* ObjectId는 "_id"의 기본 데이터형
* ObjectId 클래스는 가벼우면서, 여러 장비에 걸쳐 전역적으로 고유하게 생성하기 쉽게 설계
* 몽고DB는 분산 데이터베이스로 설계됐기 때문에 샤딩된 환경에서 고유 식별자를 생성하는 것이 매우 중요
* ObjectId는 12바이트 스토리지를 이용. 24자리 16진수 문자열 표현이 가능. 바이트당 2자리를 사용
* 여러 개의 새로운 ObjectID를 연속으로 생성하면 매번 마지막 숫자 몇 개만 바뀜
* 몇 초 간격을 두고 생성하면 ObjectID의 중간 숫자 몇 개가 바뀜
* 도큐먼트를 입력할 때 "_id" 키를 명시하지 않으면 입력된 도큐먼트에 키가 자동으로 추가

## 2.7 몽고DB 셸 사용
* 원격 몽고 서버 접속
```
mongosh some-host:port/db
```
* mongod에 연결하지 않고 시작하기
```
mongosh --nodb
conn = new Mongo("some-host:port")
db = conn.getDB("test")
```

## 2.7.1 셸 활용 팁
* mongosh는 단순하게 보면 자바스크립트 셸이므로 자바스크립트 문서 참조해도 됨
* help 입력하면 셸에 내장된 도움말 볼 수 있음
* 데이터베이스 수준의 도움말은 db.help()
* 컬렉션 수준의 도움말은 db.foo.help()
* 함수의 기능을 알고 싶으면 함수명을 괄호없이 입력하면 됨
* 함수의 시그니처는 함수명.help로 확인 가능

## 2.7.2 셸에서 스크립트 실행하기
* 자바 스크립트 파일을 셸로 전달해 실행 가능
```m
mongosh script.js
```
* load 함수를 사용해서 대화형 셸에서 스크립트를 실행할 수 있음
```m
> load('script.js')
```
* 스크립트는 db 변수에 대한 접근은 가능하지만 use db나 show collections와 같은 셸 보조자는 작동하지않음

# Chapter 3 도큐먼트 생성, 갱신, 삭제

## 3.1 도큐먼트 삽입
* 삽입은 몽고DB에 데이터를 추가하는 기본 방법
* 컬렉션의 insertOne 메서드 사용
```m
db.movies.insertOne({"title": "Batman"})
```
* 도큐먼트에 "_id" 키가 자동으로 추가

### 3.1.1 insertMany
* 여러 도큐먼트를 컬렉션에 삽입하려면 insertMany로 도큐먼트 배열을 전달
```m
db.movies.insertMany(
    [
        {"title":"Iron Man"},
        {"title":"Batman"},
        {"title":"Hulk"}
    ]
)
```
* 몽고DB의 버전에 따라 메시지의 용량에 제한이 있으므로 한 번에 일괄 삽입 할 수 있는 크기에 제한이 있다. 
* 제한된 용량보다 크면 드라이버가 여러 개로 분할
* 삽입시에 정렬 or 비정렬을 선택할 수 있다. 기본값은 정렬
* 정렬 삽입시에 중간에 에러 발생하면 해당 발생 지점부터 멈춤
* 비정렬 삽입시에 중간에 에러 발생하면 해당 도큐먼트 제외하고 다 삽입 시도

### 3.1.2 삽입 유효성 검사
* 몽고 DB는 삽입된 데이터에 최소한의 검사를 수행
* 도큐먼트의 기본 구조를 검사해 "_id" 필드가 존재하지 않으면 추가하고, 모든 도큐먼트는 16메가바이트보다 작아야 하므로 크기 검사를 함
    * [MongoDB 6.0](https://www.mongodb.com/docs/manual/core/document/) 기준으로 아직 16 megabyte. 600쪽 짜리 책이 3MB 정도 함
* 도큐먼트의 Binary JSON(BSON) 크기를 보려면 셸에서 object.bsonsize(doc)를 실행
* [MongoDB 6.0](https://www.mongodb.com/docs/v6.0/reference/operator/aggregation/bsonSize/?_ga=2.178847844.1309917206.1662172054-1070121506.1661954868&_gac=1.222154986.1662172054.Cj0KCQjw08aYBhDlARIsAA_gb0f7LPQVKS-MrGyglm8EGGAAKebt9V5XPTbslA_4WUHoHt0I31dwMA0aAj7REALw_wcB)에서 bsonsize 보는 방법

### 3.1.3 삽입
* 몽고DB 3.0 이전 버전에서는 삽입 할 때 insert 사용
* 호환성 지원 때문에 사용 할 수는 있지만 insertOne or insertMany를 사용

## 3.2 도큐먼트 삭제
* deleteOne과 deleteMany를 이용해서 삭제 가능
```m
db.movies.deleteOne({"_id": ObjectId("6312b034452fd87b69e1978c")})
```
* deleteOne은 필터에 의해 여러개가 걸리면 첫 번째 도큐먼트만 삭제
* deleteMany는 필더에 걸린거 전부 삭제
* 몽고DB 3.0 이전 버전에서는 삭제할 때 remove 사용
* 호환성 지원 때문에 사용 할 수는 있지만 deleteOne or deleteMany를 사용

### 3.2.1 drop
* deleteMany를 사용해 컬렉션의 모든 도큐먼트 삭제
* 전체 컬렉션을 삭제하려면 drop을 사용하는 편이 더 빠름
```m
db.movies.drop()
```

## 3.3 도큐먼트 갱신
* 도큐먼트는 updateOne, updateMany, replaceOne과 같은 갱신 메서드를 사용해 변경
* updateOne과 updateMany는 필터 도큐먼트를 첫 번째 매개변수로, 변경 사항을 설정하는 수정자 도큐먼트를 두 번째 매개변수로 사용
* replaceOne도 첫 번째 매개변수로 필터를 사용하지만 두 번째 매개변수는 필터와 일치하는 도큐먼트를 교체할 도큐먼트
* 갱신은 원자적으로 이뤄짐. 두 개의 갱신이 동시에 발생하면 서버에 먼저 도착한 요청이 적용된 후 다음 요청이 적용

### 3.3.1 도큐먼트 치환
* replaceOne은 도큐먼트를 새로운 것으로 완전히 치환함
* replaceOne의 필터에 2개 이상의 도큐먼트가 걸리면 갱신 실패. 고유한 값으로 시도해야됨
* "_id" 값이 컬렉션 기본 인덱스의 기초를 형성하므로 필터에 "_id"를 사용해도 효율적이다

### 3.3.2 갱신 연산자
* 부분 갱신에는 원자적 갱신 연산자를 사용
* 갱신 연산자는 키를 변경, 추가, 제거하고 배열과 내장 도큐먼트를 조작하는 복잡한 갱신 연산을 지정하는 데 사용하는 특수키다

**`$Set` 제한자 사용하기**
* `$Set`은 필드 값을 설정.
* 필드가 존재하지 않으면 새 필드 생성
```m
db.movies.updateOne(
    {"title":"Iron Man"}, 
    {
        "$set": {
            "description":"Beeem!"
        }
    }
)
```

**증가와 감소**
* `$inc` 연산자는 이미 존재하는 키의 값을 변경하거나 새 키를 생성하는 데 사용.
* 키 값은 무조건 숫자여야 함
```m
db.movies.updateOne(
    {"title":"Iron Man"}, 
    {"$inc": {"score":50}}
)
```

**배열 연산자**
* 요소 추가하기 : `$push`는 배열이 이미 존재하면 배열 끝에 요소를 추가하고, 존재하지 않으면 새로운 배열을 생성
```m
db.movies.updateOne(
    {"title":"Iron Man"}, 
    {"$push": {"actors": "toni"}}
)
```
* `$push`에 `$each` 제한자를 사용하면 작업 한 번으로 값을 여러 개 추가할 수 있음
```m
db.movies.updateOne(
    {"title":"Iron Man"}, 
    {"$push": {"actors":{"$each": ["toni", "stark"]}}}
)
```
* `$slice`를 이용해서 도큐먼트 내에 큐를 생성해 top N 목록을 만들 수 있음
```m
db.movies.updateOne(
    {"title":"Iron Man"}, 
    {"$push": {"actors":{"$each": ["toni", "stark"],
                    "$slice": -10}}}
)
```
* `$sort`를 이용해서 정렬된 상태로 추가할 수 있음
* 1 : 오름차순
* -1 : 내림차순
```m
db.movies.updateOne(
    {"title":"Iron Man"}, 
    {
        "$push": {
            "actors":
            {
                "$each": [{"name":"toni", "age":30}, 
                            {"name":"startk", "age":40}],
                "$slice": -10,
                "$sort": {"age": -1}
            }
        }
    }
)
```
* 배열을 집합으로 사용하기
* `$ne`를 사용하면 값을 추가하면서 중복을 제거
```m
db.movies.updateOne({"actors": {"$ne": "toni"}}, {"$push": {"actors": {"name":"Jone", "age": 20}}})
```
* `$addToSet`을 사용하면 `$ne`가 작동하지 않을 때나 무슨 일이 얼아났는지 더 잘 알수 있을 때 유용
* `$addToSet`을 사용하면 배열에 중복을 피할 수 있음
```m
db.movies.updateOne({"_id":ObjectId("6312b034452fd87b69e1978d")}, {"$addToSet": {"actors": {"name":"Jone", "age": 20}}})
```
* `$pop`: 배열에서 요소 제거하기
    * {"$pop":{"key":1}} : 배열의 마지막 요소부터 제거
    * {"$pop":{"key":-1}} : 배열의 첫 요소부터 제거
* `$pull`: 주어진 조건에 맞는 배열 요소를 모두 제거
```
db.lists.insertOne({"todo":["dishes", "laundry", "dry cleaning"]})
db.lists.updateOne({}, {"$pull":{"todo":"laundry"}})
```
**배열의 위치 기반 변경**
* 위치를 이용하거나 위치 연산자($)를 사용해서 변경
* 배열 인덱스는 기준이 0
* 배열 요소는 인덱스를 도큐먼트의 키처럼 사용
```m
// post를 찾아서 0번째 comments의 votes를 1 증가
db.blog.updateOne({"post": post_id},
    {"$inc":{"comments.0.votes": 1}})
```
* `$`: 쿼리 도큐먼트와 일치하는 배열 요소 및 요소의 위치를 알아내서 갱신하는 위치 연산자
```m
db.blog.updateOne({"comments.autho": "John"},
        {"$set": {"comments.$.author": "Jim}})
```

**배열 필터를 이용한 갱신**
* arrayFilters를 이용해 특정 조건에 맞는 배열 요소를 갱신할 수 있음
* `elem`: 배열의 각 일치 요소에 대한 식별자
```m
// 투표값이 -5 이하인 경우 hidden에 true 설정
db.blog.updateOne(
    {"post": post_id},
    {"$set": {"comments.$[elem].hidden": true}},
    {
        arrayFilters: [ {"elem.votes": { $lte: -5 }}]
    }
)
```

### 3.3.3 갱신 입력
* 갱신 조건에 맞는 도큐먼트가 존재하지 않을 때는 쿼리 도큐먼트와 갱신 도큐먼트를 합쳐서 새로운 도큐먼트를 생성
* 조건에 맞는 도큐먼트가 있으면 일반적인 갱신 수행
* race condition을 피할 수 있음
* updateOne과 updateMany의 세 번째 매개변수는 옵션 도큐먼트. 여기에 갱신 입력을 지정
```
db.analytics.updateOne({"url":"/blog"}, {"$inc": {"pageviews": 1}},
    {"upsert": true})
```
* `$setOnInsert`: 도큐먼트가 삽입될 때 필드 값을 설정하는 데만 사용하는 연산자
```m
db.users.updateOne({}, {"$setOnInsert": {"createdAt": new Date()}},
    {"upsert": true})
```

### 3.3.4 다중 도큐먼트 갱신
* `updateMany`: 조건에 맞는 모든 도큐먼트 수정
* 사용법은 `updateOne`이랑 동일

# Chapter 4 쿼리

## 4.1 find 소개
* 몽고DB에서 find 함수는 쿼리에 사용
* 쿼리는 컬렉션에서 도큐먼트의 서브셋을 반환
* 빈 쿼리 도큐먼트({})는 컬렉션 내 모든 것과 일치
* 쿼리 도큐먼트에 여러 키/값 쌍을 추가해 검색을 제한할 수 있다
```m
// "age"가 27인 모든 도큐먼트
db.users.find({"age": 27})
```
```m
// "username"이 "joe"인 모든 도큐먼트
db.users.find({"age": 27})
```
```m
// "age"가 27 AND "username"이 "joe"인 모든 도큐먼트
db.users.find({"age": 27})
```

### 4.1.1 반환받을 키 지정
* 원하는 키/값 정보는 두 번째 매개변수에 원하는 키를 지정하면 됨
```m
// 컬렉션에서 "username"과 "email" 키의 값만 추출
db.users.find({}, {"username": 1, "email": 1})
```
* "_id" 키는 지정하지 않아도 항상 반환됨
* 특정 키/값 쌍을 제외한 결과를 얻을 수 있음
```m
db.users.find({}, {"fatal_weakness" : 0})
```

### 4.1.2 제약 사항
* 데이터베이스에서 쿼리 도큐먼트 값은 반드시 상수여야 함. 도큐먼트 내 다른 키의 값을 참조할 수 없음

## 4.2 쿼리 조건

### 4.2.1 쿼리 조건절
* < : "$lt"
* <= : "$lte"
* > : "$gt"
* >= : "$gte"
```m
db.users.find({"age": {"$gte": 18, "$lte" : 30}})
```
```m
start = new Date("01/01/2007")
db.users.find({"registered": {"$lt": start}})
```
* != : "$ne"
```m
db.users.find({"username": {"$ne": "joe"}})
```

### 4.2.2 OR 쿼리
* "$in" : 포함. 하나의 키를 다양한 값과 비교
* "$nin" : 미포함. 하나의 키를 다양한 값과 비교
* "$or" : 여러 키를 주어진 값과 비교
```m
// 포함
db.raffle.find({"ticket_no": {"$in": [725, 542, 390]}})
// 미포함
db.raffle.find({"ticket_no": {"$nin": [725, 542, 390]}}) 
// or
db.raffle.find({"$or": [{"ticket_no": 725}, {"winner": true}]})
```

### 4.2.3 $not
* "$not"은 메타 조건절이며 어떤 조건에도 적용할 수 있음
```
db.users.find({"id_num": {"$not" : {"$mod": [5, 1]}}})
```

## 4.3 형 특정 쿼리
* 도큐먼트 내에서 다양한 데이터형 사용 가능. 일부 데이터형은 쿼리 시 형에 특정하게 작동

### 4.3.1 null
* null은 스스로와 일치하는 것을 찾음
```m
db.c.find({"y": null})
```
### 4.3.2 정규 표현식
* "$regex"는 쿼리에서 패턴 일치 문자열을 위한 정규식 기능을 제공
```m
db.users.find({"name": {"$regex": /joe/i }})
```
* 자바스크립트에서 정규표현식이 제대로 동작하는지 확인 하는게 좋음
* 접두사 정규 표현식에 쿼리 인덱스 활용 가능

### 4.3.3 배열에 쿼리하기
* 배열 요소 쿼리는 스칼라 쿼리와 같은 방식으로 동작하도록 설계
```m
db.food.insertOne({"fruit": ["apple", "banana", "paech"]})
db.food.find({"fruit": "banana"})
```
* $all 연산자 : 2개 이상의 배열 요소가 일치하는 배열을 찾을 때 사용
```m
db.food.find({"fruit": {$all: ["banana","peach"]}})
```
* $size 연산자 : 특정 크기의 배열을 쿼리하는 조건
```m
db.food.find({"fruit": {"$size": 3}})
```
* $slice 연산자 : 배열 요소의 부분집합을 반환받을 수 있음
```m
// 처음 10개
db.blog.posts.findOne(criteria, {"comments": {"$slice" : 10}})
// 마지막 10개
db.blog.posts.findOne(criteria, {"comments": {"$slice" : -10}})
// 24 ~ 33째 까지 반환
db.blog.posts.findOne(criteria, {"comments": {"$slice" : [23, 10]}})
```
* $ : 배열 요소의 인덱스를 알고 있다면 인덱스가 일치하는 배열 요소의 반환.
```m
db.blog.posts.findOne({"comments.name": "bob", {"comments.$": 1} })
```

**배열 및 범위 쿼리의 상호작용**
```m
{"x": 5}
{"x": 15}
{"x": 25}
{"x": [5, 25]}
```
* 위와 같은 데이터가 있을 때 아래처럼 쿼리하면 15, [5, 25]가 나옴
```m
db.xs.find({"x": {$gt: 10, $lt: 20}})
```
* $elemMatch로 막을 수 있지만 배열이 아니면 일치시키지 않음
```m
db.xs.find({"x": {$elemMatch: {$gt: 10, $lt: 20}}})
```

### 4.3.4 내장 도큐먼트에 쿼리하기
* 도큐먼트 전체를 대상으로 하는 방식과 도큐먼트 내 키/값 쌍 각각을 대상으로 하는 방식으로 나뉨
```m
// 전체 도큐먼트를 대상으로 하는 쿼리
db.people.find({"name":{"first":"joe", "last":"Schmoe"}})
// 내장 도큐먼트에 쿼리하는 방식
db.people.find({"name.first": "joe", "name.last":"Schmoe"})
```

## $4.4 where 쿼리
* $where 절을 사용해 임의의 자바스크립트를 쿼리의 일부분으로 실행하면 모든 쿼리를 표현할 수 있음
* 보안에 취약함
* 일반 쿼리보다 많이 느리니 반드시 필요한 경우가 아니면 자제

## 4.5 커서
* 커서를 사용해 find의 결과를 반환
```m
var cusor = db.foo.find()

while(cursor.hasNext()){
    obj = cursor.next()
    // something
}
```
* cursor 클래스는 자바스크립트의 반복자 인터페이스를 구현해서 forEach 가능

### 4.5.1 제한, 건너뛰기, 정렬
* limit : 결과 개수 제한
```m
db.c.find().limit(3)
```
* skip : 특정 개수만큼 건너띄고 나머지 반환
```m
db.c.find().skip(3)
```
* sort : 객체를 매개변수로 받아서 정렬. 
    - 매객변수는 키/값 쌍. 
    - 키는 키의 이름. 
    - 값은 정렬 방향. 
    - 오름차순 : 1, 내림차순 : -1
    - 큰 수를 건너뛰면 비효율적
```m
db.c.find().sort({username: 1, age: -1})
```

**비교 순서**
* 몽고DB에는 데이터형을 비교하는 위계 구조가 있음
* 데이터형이 섞여 있는 키는 미리 정의된 순서에 따라 정렬
    1. 최솟값
    2. null
    3. 숫자
    4. 문자열
    5. 객체/도큐먼트
    6. 배열
    7. 이진 데이터
    8. 객체 ID
    9. 불리언
    10. 날짜
    11. 타임스탬프
    12. 정규 표현식
    13. 최댓값

### 4.5.2 많은 수의 건너뛰기 피하기
* skip은 생략된 결과물을 모두 찾아 폐기하므로 결과가 많이 느려짐

**cursor를 이용한 방법**
* date 키를 기준으로 내림차순 정렬된 도큐먼트가 있음
```m
var page1 = db.foo.find().sort({"date": -1}).limit(100)

var latest = null

// 1 페이지 출력
while (page1.hasNext()){
    latest = page1. next()
    display(latest)
}

// 다음 페이지는 이전 페이지의 마지막 날짜를 기준으로 가져옴
var page2 = db.foo.find({"date": {"$lt": latest.data}})
page2.sort({"date": -1}).limit(100)
```

### 4.5.3 종료되지 않는 커서
* 커서는 클라이언트측 커서와, 데이터베이스 커서가 있음
* 서버 측에서 보면 커서는 메모리와 리소스를 점유
* 커서가 더는 가져올 결과가 없거나 클라이언트로부터 종료 요청을 받으면 데이터베이스는 점유하고 있던 리소스를 해제
* 서버 커서를 종료하는 몇가지 조건
    * 조건에 일치하는 결과를 모두 살펴본 후 스스로 정리
    * 커서가 클라이언트측에서 유효 영역을 벗어난 경우
    * 10분 동안 활동이 없는 경우

# Chapter 5 인덱싱

## 5.1 인덱싱 소개
* 데이터베이스 인덱스는 책의 인덱스와 유사
* 엄청난 양의 명령을 더 빠르게 쿼리할 수 있음
* 인덱스를 사용하지 않는 쿼리를 컬렉션 스캔이라 함. 
    - RDB에서는 Full Table Scan 정도가 될듯?
    - 너무 느림
* explain 함수로 쿼리 실행 계획 확인
```m
db.users.find({"username": "user01"}).explain("executionStats")
```

### 5.1.1 인덱스 생성
* `createIndex` : 인덱스를 만드는 컬렉션 메서드
```m
db.users.createIndex({"username": 1})
```

### 5.1.2 복합 인덱스 쇅
* 2개 이상의 필드로 구성된 인덱스
* 각 인덱스 항목은 설정된 키를 포함하고 레코드 식별자를 가리킴
* 레코드 식별자는내부에서 스토리지 엔진에 의해 사용
* 몽고DB는 인덱스를 어느 방향으로도 쉽게 탐색할 수 있음

### 5.1.3 몽고DB가 인덱스를 선택하는 방법
* 쿼리가 들어오면 쿼리 모양을 확인
    * 검색할 필드, 정렬 여부 등의 추가 정보가 있음
* 이 정보를 기반으로 쿼리를 충족하는 데 사용할 인덱스 후보 집합을 식별
* 인덱스 후보를 대상으로 쿼리 플랜을 만듬
* 병렬 스레드에서 쿼리 실행
* 제일 먼저 실행된 쿼리와 동일한 모양을 가진 쿼리에 사용할 인덱스로 사용
* 서버는 쿼리 플랜의 캐시를 유지
* 컬렉션과 인덱스가 변경되면 쿼리 플랜 캐시가 제거

### 5.1.4 복합 인덱스 사용
* 읽기와 쓰기를 가능한한 효율적으로 수행하도록 인덱스를 설계
* 인덱스를 올바르게 설계하려면 실제 워크로드에서 인덱스를 테스트하고 조정해야 함
* 모범사례
    * 인덱스의 선택성 : 특정 쿼리 패턴에서 스캔할 레코드 개수를 인덱스가 얼마나 최소화 하는지


### 5.1.5 $ 연산자의 인덱스 사용법
* $ne 쿼리는 인덱스를 잘 활용하지 못함
* $not을 사용하는 쿼리 대부분은 테이블 스캔을 수행
* $nin은 항상 테이블 스캔 수행
* 범위에 사용될 필드는 인덱스의 마지막에 놓는게 좋음
* 보통 쿼리 하나당 하나의 인덱스만 사용
    * $or는 절마다 하나씩 인덱스를 사용할 수 있음

### 5.1.6 객체 및 배열 인덱싱
* 내장 필드와 배열에 인덱스 생성 가능
```m
//서브 필드
db.users.createIndex({"loc.city": 1})
// 배열
db.users.createIndex({"comments.date" : 1})
```

## 5.2 explain 출력
* explain은 쿼리에 대한 많은 정보를 제공
* 샤딩은 쿼리를 여러 서버에서 수행하므로 explain들의 집합체를 반환
* 쿼리가 CALLSCAN이면 엔덱스 사용 안함
* isMultiKey : 다중키 인덱스 사용 여부
* nReturned : 쿼리에 의해 반환된 도큐먼트 개수
* totalDocsExamined : 몽고 DB가 디스크 내 실제 도큐먼트를 가리키는 인덱스 포인터를 따라간 횟수
* totalKeysExamin : 인덱스가 사용됐다면 살펴본 인덱스 항목 개수, 테이블 스캔을 했다면 조사한 도큐먼트 개수
* stage : 몽고DB가 인덱스를 사용해 쿼리할 수 있었는지 여부
* needYields : 쓰기 요청을 처리하도록 쿼리가 양보(yield, 일시 중지) 한 횟수
* executionTimeMillis : 쿼리하는 데 걸린 시간
* indexBounds : 인덱스가 어떻게 사용됐는지 설명

## 5.3 인덱스를 생성하지 않는 경우
* 인덱스는 데이터의 일부를 조회할 때 가장 효율적
* 인덱스가 없는 게 더 빠른 쿼리도 있음
* 인덱스가 적합한 경우 : 큰 컬렉션, 큰 도큐먼트, 선택적 쿼리
* 컬렉션 스캔이 적합한 경우 : 작은 컬렉션, 작은 도큐먼트, 비선택적 쿼리

## 5.4 인덱스 종류

### 5.4.1 고유 인덱스
* 각 값이 인덱스에 최대 한 번 나타나도록 보장
* 고유 인덱스인 _id의 인덱스는 컬렉션을 생성하면 항상 자동으로 생성
* 인덱스 버킷은 크기 제한이 있으며 제한을 넘는 인덱스 항목은 인덱스에 포함되지 않음
* 복합 고유 인덱스를 만들 수도 있음
* 고유 인덱스를 구축할 때 중복된 값이 있으면 실패함

### 5.4.2 부분 인덱스
* partialFilterExpression 옵션을 포함해서 생성

## 5.5 인덱스 관리
* 동일한 인덱스를 다시 생성하면 아무일도 안 일어남
* 데이터베이스의 인덱스 정보는 모두 system.indexes 컬렉션에 저장
    - 수정 및 제거 불가능

### 5.5.1 인덱스 식별
* 인덱슴여 : 컬렉션 내 각 인덱스는 고유하게 식별하는 이름

### 5.5.2 인덱스 변경
* dropIndex : 인덱스 제거
