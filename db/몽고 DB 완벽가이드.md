# Chapter 1 몽고DB 소개
* 몽고 DB는 강력하고 유연하며 확장성 높은 범용 데이터베이스이다
* 보조 인덱스, 범위 쿼리, 정렬, 집계, 공간 정보 인덱스 등을 확장 기능과 결합

## 1.1 손쉬운 사용
* 몽고 DB는 `도큐먼트 지향` 데이터베이스다
* 분산 확장을 쉽게 하기 위함
* 행 개념 대신에 보다 유연한 모델인 도큐먼트를 사용
* 내장 도큐먼트와 배열을 허용함으로써 도큐먼트 지향 모델은 복잡한 계층 관계를 하나의 레코드로 표현
* 고정된 스키마가 없음. 필요 시 쉽게 필드를 추가하거나 제거할 수 있음

## 1.2 확장 가능한 설계
* 저장할 데이터가 증가함에 따라, 데이터베이스를 어떻게 확장할 것인가와 같은 어려운 의사 결정을 해야 하는 상황에 직면함
* 스케일 업 or 스케일 아웃 중 선택해야 함
    * 스케일 업은 단순하고 쉽지만 비싸고 물리적인 한계가 있음
    * 스케일 아웃은 경제적이고 확장이 용이함. 하지만 관리가 어려움
* 몽고DB는 분산 확장을 염두에 두고 설계
* 기존에 배포된 애플리케이션의 토폴로지를 변경할 때도 애플리케이션 로직은 그대로 유지 가능

## 1.3 다양한 기능
* 몽고 DB는 CRDU 외에도 DBMS의 대부분의 기능과 더불아 아래 기능들을 제공
* 인덱싱
    * 일반적으로 보조 인덱스를 지원
    * 고유, 복합, 공간 정보, 전문 인덱싱 기능도 제공
* 집계
    * 데이터 처리 파이프라인 개념을 기반으로 한 집계 프레임워크를 제공
* 특수한 컬렉션 유형
    * 특정 시간에 만료해야 하는 데이터에 대해 유효 시간(TTL) 지원
    * 기준 필터와 일치하는 도큐먼트에 한정된 부분 인덱스 지원
* 파일 스토리지
    * 큰 파일과 파일 메타데이터를 편리하게 저장하는 프로토콜을 지원
* RDB에 사용되는 일부 기능, 특히 복잡한 조인은 존재하지 않음

## 1.4 고성능
* 몽고 DB에서는 동시성과 처리량을 극대화하기 위해 와이어드타이거 스토리지 엔진에 기회적 락을 사용

# Chapter 2 몽고DB 기본
* 몽고 DB 데이터의 기본 단위는 도큐먼트이며, RDB의 행과 유사
* 같은 맥락에서 컬렉션은 동적 스키마가 있는 테이블과 같음
* 몽고 DB의 단일 인스턴스는 자체적인 컬렉션을 갖는 여러 개의 독립적인 데이터베이스를 호스팅
* 모든 도큐먼트는 컬렉션 내에서 고유한 특수키인 "_id"를 가짐
* 몽고 DB는 몽고 셸이라는 도구와 함께 배포

## 2.1 도큐먼트
* 도큐먼트 : 정렬된 키와 연결된 값의 집합
* 도큐먼트 표현 방식 : 맵, 해시, 딕셔너리 같은 자료구조
* 도큐먼트의 키는 문자열. 아래를 제외한 UTF-8이면 가능
    * \0(null) 미포함, \0은 키의 끝을 나타내는 데 사용
    * .과 $는 예약어
* 데이터형과 대소문자를 구분
* 키가 중복될 수 없음

## 2.2 컬렉션
* 도큐먼트의 모음
* 도큐먼트가 행에 대응된다면 컬렉션은 테이블에 대응

### 2.2.1 동적 스키마
* 컬렉션은 동적 스키마를 가짐
* 하나의 컬렉션 내 도큐먼트들이 모두 다른 구조를 가질 수 있다
* 도큐먼트들의 키, 키의 개수, 데이터형의 값은 모두 다름
* 다른 구조의 도큐먼트라도 같은 컬렉션에 저장하면 안되는 이유
    * 같은 컬렉션에 다른 종류의 도큐먼트를 저장하면 개발자와 관리자에게 번거로움
    * 컬렌션별로 목록을 뽑으면 빠름
    * 같은 종류의 데이터를 하나의 컬렉션에 모아두면 데이터 지역성에 좋다
    * 인덱스를 만들면 도큐먼트는 특정 구조를 가져야 함

### 2.2.2 네이밍
* 컬렉션은 이름으로 식별
* 어떤 UTF-8 문자든 쓸 수 있지만 제약 이있음
* 제약
    * 빈 문자열은 안됨
    * \0(null) 안됨
    * system.은 예약어라 안됨
    * $는 예약어라 안됨

**서브 컬렉션**
* 서브컬렉션의 네임스페이스에 .(마침표) 문자를 사용해 컬렉션을 체계화한다.
* 예로 블로그 기능이 있는 애플리케이션은 `blog.posts`와 `blog.authors`라는 컬렉션을 가짐
* 서브컬렉션은 몽고DB의 데이터를 체계화하는 좋은 방법

## 2.3 데이터베이스
* 몽고DB는 데이터베이스에 컬렉션을 그룹지어 놓음
* 몽고 DB의 단일 인스턴스는 여러 데이터베이스를 호스팅 할 수 있음
* 각 데이터베이스를 완전히 독립적으로 취급 가능
* 데이터베이스 이름 규칙
    * 어떤 UTF-8 문자열 가능
    * 빈 문자열 안됨
    * 다음 문자 안됨. /, \, ., ' ', *, <, >, :, |, ?, $, (single space), \0(null)
    * 대소문자 구별
    * 최대 64바이트
* 직접 접근할 수 있지만 예약된 데이터베이스 이름
    * admin : 인증과 권한 부여 역할
    * local : 단일 서버에 대한 데이터를 저장
    * config : 샤딩된 몽고DB 클러스터는 config 데이터베이스를 샤용해 각 샤드의 정보를 저장

## 2.4 몽고DB 시작
* 서버를 시작하려면 유닉스 명령행 환경에서 mongod 실행 파일 실행
* mongod는 인수 없이 실행하면 기본 데이터 디렉터리로 /data/db를 사용
* 데이터 디렉터리가 없거나 쓰기 권한이 없을 때는 서버가 시작되지 않음
* 기본 포트는 27017
* mongod 서버를 실행한 셸에서 `Ctrl` + `C`를 누르면 graceful down 됨

* brew를 이용한 Mongo DB 설치 및 실행, 종료
```
brew tap mongodb/brew
brew update
brew install mongodb-community@5.0
//자동
brew services start mongodb-community@5.0
brew services stop mongodb-community@5.0

//수동 - Apple M1
mongod --config /opt/homebrew/etc/mongod.conf --fork
```
## 2.5 몽고DB 셸 소개
* 몽고DB는 명령행에서 몽고DB 인스턴스와 상호작용하는 자바스크립트 셸을 제공

### 2.5.1 셸 실행
* 책에는 mongo를 실행하면 된다 하는데 6버전 부터는 mongosh 인듯
* 셸은 완전한 자바스크립트 해석기임

### 2.5.2 몽고DB 클라이언트
* 셸은 독자적으로 쓸 수 있는 몽고DB 클라이언트
* 셸은 시작할 때 몽고DB 서버의 test 데이터베이스에 연결. 데이터베이스 연결을 전역 변수 db에 할당
```
> db
test
```
* 데이터베이스 선택 작업
```
> use video
switched to db video
>db
video
```
* 자바스크립트 셸이므로 변수 이름을 입력하면 표현식으로 평가.
* 아래와 같이 DB 변수에서 컬렉션에 접근
```
> db.movies
```

### 2.5.3 셸 기본 작업
* 셸에서 데이터를 조작하거나 보려면 CRUD의 네 가지 기본적인 작업을 함

**생성, Create**
* `insertOne` 함수는 컬렉션에 도큐먼트를 추가
* 영화를 저장한다고 가정
    * movie라는 지역 변수를 생성하고 객체를 할당
    ```
    movie = {"title":"연가시", "director":"봉준호","year":2018}
    ```
    * 위 객체를 `insertOne` 함수를 이용해서 movies 컬렉션에 저장
    ```
    > db.movies.insertOne(movie)
    ```
    * 데이터베이스에 저장된 컬렉션에서 find를 호출해서 확인
    ```
    > db.movies.find().pretty()
    ```

**읽기, Read**
* `find`와 `findOne`은 컬렉션을 쿼리하는 데 사용
* 컬렉션에서 단일 도큐먼트 읽기
```
> db.movies.findOne()
```
* `find`와 `findOne`은 `쿼리 도큐먼트` 형태로 조건 전달도 가능

**갱신, Update**
* 게시물을 갱신하려면 `updateOne`을 사용. 최소 2개의 매개변수 필요
* 첫 번째는 수정할 도큐먼트를  찾는 기준, 두 번째는 갱신 작업을 설명하는 도큐먼트
* 앞서 만든 영화에서 리뷰 기능을 사용하기로 결정했다 가정
```
> db.movies.updateOne({title: "연가시"}, {$set: {revies:[]}})
```

**삭제, Delete**
* deleteOne과 deleteMany는 도큐먼트를 데이터베이스에서 영구적으로 삭제
* 두 함수 모두 필터 도큐먼트로 삭제 조건을 지정
```
> db.movies.deleteOne({title: "연가시"})
```
* 필터와 일치하는 모든 도큐먼트를 삭제하려면 deleteMayn 사용
