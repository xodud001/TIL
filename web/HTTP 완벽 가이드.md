# HTTP: 웹의 기초

## **1장 HTTP 개관**
이번 장에서 다루게 될 것
* 얼마나 많은 클라이언트와 서버가 통신하는지
* 리소스가(웹 콘텐츠) 어디서 오는지
* 웹 트랜잭션이 어떻게 동작하는지
* HTTP 통신을 위해 사용하는 메시지의 형식
* HTTP 기저의 TCP 네트워크 전송
* 여러 종류의 HTTP 프로토콜
* 인터넷 곳곳에 설치된 다양한 HTTP 구성요소

### **1.1 HTTP: 인터넷의 멀티미디어 배달부**
* HTTP는 전 세계의 웹 서버로부터 대량의 정보를 빠르고, 간편하고 정확하게 사람들의 PC에 설치 된 웹브라우저로 옮겨준다.
* HTTP는 `신뢰성 있는 데이터 전송 프로토콜을 사용`하기 때문에, 전송 중 손상되지 않음을 보장한다.

### **1.2 웹 클라이언트와 서버**
* 웹 콘텐츠는 웹 서버에 존재
* 웹 서버는 데이터를 저장하고 HTTP 클라이언트가 요청한 데이터를 제공
* 웹브라우저 같은 것들을 HTTP 클라이언트라고 함

### **1.3 리소스**
* 웹 서버는 웹 리소스를 관리하고 제공
* `정적 리소스` - 이미지, HTML 파일, 텍스트 파일, 워드 파일 등
* `동적 리소스` - 요청에 따라 달라짐. 카메라 라이브 영상, 주식 거래, 부동산 데이터베이스 등
* 어떤 종류의 콘텐츠 소스도 리소스가 될 수 있음

#### **1.3.1 미디어 타입**
* 인터넷은 수천 가지 데이터 타입을 다루기 때문에, HTTP는 웹에서 전송되는 객체 각각에 MIME 타입이라는 데이터 포맷 라벨을 붙인다.
    * `MIME` : Multipurpose Internet Mail Extensions
* MIME는 원래 각기 다른 전자메일 시스템 사이에서 메시지가 오갈 때 겪는 문제점을 해결하기 위해 설계
* MIME가 이메일에서 잘 동작해서, HTTP에서도 멀티미디어 콘텐츠를 기술하고 라벨을 붙이기 위해 채택
* MIME 타입은 사선(/)으로 구분된 주 타입과 부 타입으로 이루어진 문자열 라벨.
    * HTML로 작성된 텍스트 문서 : `text/html`
    * plain ASCII 텍스트 문서 : `text/plain`
    * JPEG 이미지 : `image/jpeg`
    * GIF 이미지 : `image/gif`

#### **1.3.2 URI**
* 웹 서버 리소스는 각자 이름을 갖고 있음. 클라이언트는 관심 있는 리소스 지목 가능
* 서버 리소스 이름은 `통합 자원 식별자, 혹은 URI(uniform resource identifier)`로 불림
* URI는 정보 리소스를 고유하게 식별하고 위치를 지정할 수 있다.

#### **1.3.3 URL**
* `통합 자원 지시자(uniform resource locator, URL)`는 리소스 식별자의 가장 흔한 형태
* URL은 특정 서버의 한 리소스에 대한 구체적인 위치를 서술
* 대부분의 URL은 세 부분으로 이루어진 표준 포맷을 따름
    * URL의 첫 번째 부분은 스킴(scheme)이라고 불리는데, 리소스에 접근하기 위해 사용되는 프로토콜을 서술. ex) HTTP, FTP, WS ...
    * 두 번째 부분은 서버의 인터넷 주소를 제공
    * 마지막은 웹 서버의 리소스를 지정
* 오늘날 대부분의 URI는 URL임

#### **1.3.4 URN**
* `유니폼 리소스 이름(uniform resource name, URN)`은 콘텐츠를 이루는 한 리소스에 대해, 그 리소스의 위치에 영향 받지 않는 유일무이한 이름 역할을 함
* URN은 위치에 독립적이며, 리소스를 여기저기 옮기더라도 문제 없이 동작한다.

### **1.4 트랜잭션**
* HTTP 트랜잭션은 요청 명령과 응답 결과로 구성되어 있다

#### **1.4.1 메서드**
* HTTP는 `HTTP 메서드`라고 불리는 여러 종류의 요청 명령을 지원
* 모든 HTTP 요청은 한 개의 메서드를 가짐
    * `GET` : 서버에서 클라이언트로 지정한 리소스를 보내라
    * `PUT` : 클라이언트에서 서버로 보낸 데이터를 지정한 이름의 리소스로 저장하라
    * `DELETE` : 지정한 리소스를 서버에서 삭제하라
    * `POST` : 클라이언트 데이터를 서버 게이트웨이 애플리케이션으로 보내라
    * `HEAD` : 지정한 리소스에 대한 응답에서, HTTP 헤더 부분만 보내라

#### **1.4.2 상태 코드**
* 모든 HTTP 응답 메시지는 `상태 코드`와 함께 반환
* 상태 코드는 클라이언트에게 요청이 성공했는지 아니면 추가 조치가 필요한지 알려주는 세 자리 숫자
    * `200` : 문서가 올바르게 반환
    * `302` : 자원을 다른 곳에 가서 가져가라
    * `404` : 리소스 못 찾음
* HTTP는 숫자 상태 코드에 텍스트로 된 `사유 구절(reason phrase)`도 함께 보냄
    * `200 OK`
    * `200 DOcument attached`
    * `200 Success`
    * `200 All's cool, dude`

#### **1.4.3 웹페이지는 여러 객체로 이루어질 수 있다
* 애플리케이션은 보통 하나의 작업을 수행하기 위해 여러 HTTP 트랜잭션을 수행
* 웹페이지는 보통 하나의 리소스가 아닌 리소스의 모음이다

### **1.5 메시지**
* HTTP 메시지는 사람이 읽고 쓸 수 있는 단순한 줄 단위의 문자열이다.
* HTTP 메시지는 다음의 세 부분으로 이루어 짐
    * 시작줄 : 요청이라몃 무엇을 해야하는지, 응답이라면 무슨 일이 일어났는지 서술
    * 헤더 : 시작줄 다음에는 0개 이상의 헤더 필드가 이어짐. 콜론(:)으로 구분되어 키 밸류 형식으로 구성 
    * 본문 : 헤더 아래 빈줄 다음 어떤 종류으 데이터든 필요에 따라 들어갈 수 있다. 텍스트와 이진 데이터 포함 가능

### **1.6 TCP 커넥션**
* HTTP 메시지 전송에 사용

#### **1.6.1 TCP/IP**
* HTTP는 통신의 세부사항에 대해 신경쓰지 않음. 대중적이고 신뢰성 있는 인터넷 전송 프로토콜인 TCP/IP에게 맡긴다
* TCP가 제공하는 것
    * 오류 없는 데이터 전송
    * 순서에 맞는 전달
    * 조각나지 않는 데이터 스트림

#### **1.6.2 접속, IP 주소, 포트번호
* TCP/IP 커넥션에는 인터넷 프로토콜(IP) 주소와 포트번호가 필요

### **1.7 프로토콜 버전**
HTTP 프로토콜의 다양한 버전.

**HTTP/0.9**
* GET 메서드만 지원
* 멀티미디어 콘텐츠에 대한 MIME 타입이나 HTTP 헤더, 버전 번호를 지원하지 않음
* 금방 HTTP/1.0으로 대체

**HTTP/1.0**
* 버전 번호, HTTP 헤더, 추가 메서드, 멀티미디어 객체 처리 추가
* 웹페이지와 상호작용하는 폼을 실현

**HTTP/1.0+**
* 오래 지속되는 "keep-alive" 커넥션, 가상 호스팅 지원, 프락시 연결 지원을 포함한 많은 기능이 비공식적이지만 사실상 표준으로 HTTP에 추가

**HTTP/1.1**
* HTTP 설계의 구조적 결함 교정, 두드러진 성능 최적화, 잘못된 기능 제거에 집중
* 더 복잡한 웹 애플리케이션 베포 지원
* 현재 자주 사용하는 버전

**HTTP/2.0**
* HTTP/1.1 성능 문제를 개선하기 위해 구글의 SPDY 프로토콜을 기반으로 설계

### **1.8 웹의 구성요소**
다양한 웹의 구성요소들

**프락시**
* 클라이언트와 서버 사이에 위치한 HTTP 중개자

**캐시**
* 많이 찾는 웹페이지를 클라이언트 가까이에 보관하는 HTTP 창고

**게이트웨이**
* 다른 애플리케이션과 연결된 특별한 웹 서버

**터널**
* 단순히 HTTP 통신을 전달하기만 하는 특별한 프락시

**에이전트**
* 자동화된 HTTP 요청을 만드는 준지능적 웹클라이언트

#### **1.8.1 프락시**
* 웹 보안, 애플리케이션 통합, 성능 최적화를 위한 중요한 구성요소
* 클라이언트와 서버 사이에 위치하여 클라이언트의 모든 HTTP 요청을 받아 서버에 전달
* 주로 보안을 위해 사용
* 요청와 응답을 필터링

#### **1.8.2 캐시**
* 웹캐시와 캐시 프락시는 자신을 거쳐 가는 문서들 중 자주 찾는 것의 사본을 저장 해 두는 특별한 종류의 HTTP 프락시 서버

#### **1.8.3 캐시**
* 다른 서버들의 중개자로 동작하는 특별한 서버
* 주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용

#### **1.8.4 터널**
* 터널은 두 커넥션 사이에서 날(raw) 데이터를 열어보지 않고 그대로 전달해주는 HTTP 애플리케이션
* 예, 암호화된 SSL 트래픽을 HTTP 커넥션으로 전송함으로써 웹 트래픽만 허용하는 사내 방화벽을 통과

#### **1.8.5 에이전트**
* 사용자를 위해 HTTP 요청을 만들어주는 클라이언트 프로그램
* 웹브라우저, 스파이더, 웹로봇 등


## **2장 URL과 리소스**
* URL은 인터넷의 리소스를 가리키는 표준이름.
    * 리소스: 텍스트, 이미지, 동영상 같이 웹에서 사용되는 식별을 할 수 있는 모든 자원을 가리킴
* URL은 전자정보 일부를 가리키고 그것이 어디에 있고 어떻게 접근할 수 있는지 알려줌

### **2.1 인터넷의 리소스 탐색하기**
* URL은 브라우저가 정보를 찾는데 필요한 리소스의 위치를 가리킴
* URL은 통합 자원 식별자(Uniform Resource Identifier) 혹은 URI라고 불리는 더 일반화된 부류의 부분집합
* `http://naver.com/cafe/index.html`
    * URL의 첫 부분인 `http`는 URL의 스킴이다. 어떤 프로토콜을 사용해 접근하는지 알려줌
    * URL의 두 번째 부분인 `naver.com`은 서버의 위치이다. 리소스가 어디에 호스팅 되어 있는지 알려준다
    * URL의 세 번째 부분인 `/cafe/index.html`은 리소의 경로이다. 경로는 서버에 존재하는 로컬 리소스들 중에서 요청받은 리소스가 무엇인지 알려줌

### **2.2 URL 문법**
* 대부분의 URL 스킴의 문법은 일반적으로 9개 부분으로 나뉨
* `<스킴>://<사용자이름>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>?<질의>#<프래그먼트>`

| 컴포넌트 | 설명 | 기본값 |
|--------|-----|------|
스킴      | 서버 접근에 사용하는 프로토콜 | 없음
사용자 이름 | 리소스 접근에 필요한 사용자 이름 | anonymous
비밀번호   | 사용자의 비밀번호 |<이메일 주소>
호스트    | 리소스를 호스팅하는 서버의 호스트 명이나 IP 주소 | 없음
포트      | 리소스를 호스팅하는 서버가 열어놓은 포트번호 | 스킴에 따라 다름
경로    | 서버 내 리소스가 서버 어디에 있는지를 가리킴 | 없음
파라미터 | 특정 스킴들에서 입력 파라미터를 기술하는 용도로 사용 | 없음
질의    | 스킴에서 애플리케이션에 파라미터를 전달하는데 사용 | 없음
프래그먼트 | 리소스의 조각이나 일부분을 가리키는 이름 | 없음

#### **2.2.1 스킴: 사용할 프로토콜**
* URL을 해석하는 애플리케이션이 어떤 프로토콜을 사용하여 리소스를 요청해야 하는지 알려줌
* 대소문자 구분 안 함

#### **2.2.2 호스트와 포트**
* 리소스를 찾기 위해 리소스가 호스팅하고 있는 장비와 그 장비 내에서 리소스에 접근할 수 있는 서버가 어디에 있는지 알려줌

#### **2.2.3 사용자 이름과 비밀번호**
* 서버가 가지고 있는 데이터에 접근을 허용하기 전에 사용자 이름과 비밀번호를 요구하는데 그때 사용

#### **2.2.4 경로**
* 리소스가 서버의 어디에 있는지 알려줌
* `/`문자를 기준으로 경로조각으로 나뉨

#### **2.2.5 파라미터**
* 서버에 정확한 요청을 하기 위해 필요한 입력 파라미터를 받는데 사용
* 이름/값 쌍의 리스트로 `;`로 구분해서 URL에 기술

#### **2.2.6 질의 문자열**
* 데이터베이스 같은 서비스들은 요청받을 리소스 형식의 범위를 좁히기 위해 질의문이나 질의를 받음
* `&`로 나뉜 `이름=값` 쌍 형식의 질의 문자열을 사용

#### **2.2.7 프래그먼트**
* HTML 같은 리소스 형식들은 본래의 수준보다 더 작게 나뉠 수 있음
* 리소스의 특정 부분을 가리킬 수 있도록, URL은 리소스 내의 조각을 가리킬 수 있는 프래그먼트 컴포넌트를 제공
* 프래그먼트는 브라우저가 서버에서 전체 리소스를 내려받은 후, 프래그먼트를 사용하여 리소스의 일부를 보여줌

### **2.3 단축 URL**
* 웹 클라이언트는 몇몇 단축 URL을 인식하고 사용

#### **2.3.1 상대 URL**
* URL은 상대 URL과 절대 URL로 나뉨
* 절대 URL은 리소스 접근에 필요한 모든 정보를 담고 있지만 상대 URL은 모든 정보를 담고 있지 않다
* 상대 URL로 리소스에 접근하는데 필요한 모든 정보를 얻기 위해서는 `기저(base)`라고 하는 다른 URL을 사용해야 함
    * 기저 URL : `http://naver.com/first.html`
    * 상대 URL : `./second.html`
    * 기저 URL + 상대 URL : `http://naver.com/second.html`

* 기저 URL : 변환 과정의 첫 단계는 기저 URL을 찾는 것.
* 기저 URL을 가져오는 방법
    * 리소스에 명시적으로 제공
    * 리소스를 포함하고 있는 기저 URL : 상대 URL이 기저 URL이 명시되지 않은 리소스에 포함된 경우, 해당 리소스의 URL을 기저 URL로 쓸 수 있다.
    * 기저 URL이 없는 경우 : 절대 URL로만 이루어져 있거나 불완전하거나 깨진 것
    * 상대 참조 해석하기
    
#### **2.3.2 URL 확장**
* 브라우저는 URL을 입력하는 중에 URL을 자동으로 확장함.
* 확장의 2가지 방법
    * 호스트 명 확장 : 주소에 `yahoo`를 입력하면 브라우저가 `www.`와 `.com`을 붙여서 `www.yahoo.com`으로 만드는 방식
    * 히스토리 확장 : 과거에 사용자가 방문했던 URL 기록을 저장.

### **2.4 안전하지 않은 문자**
* URL은 일반적으로 안전한 알파벳 문자만 포함하도록 허락함
* 근데 URL에 이진데이터나 다른 문자도 포함할 때가 있음. 이때 이스케이프라는 기능을 이용해서 안전하지 않은 문자를 안전한 문자로 인코딩 할 수 있다

#### **2.4.1 URL 문자 집합**
* 컴퓨터의 기본 문자 집합은 보통 영어 중심임
* URL에 포함할 수없는 문자를 포함하기 위해 이스케이프 기능을 지원.
* 이스케이프 문자열은 US-ASCII에서 사용이 금지된 문자들로, 특정 문자나 데이터를 인코딩할 수 있게 함으로써 이동성과 완성도를 높임

#### **2.4.1 인코딩 체계**
* 안전하지 않은 문자들을 표현할 수 있는 인코딩 방식이 고안
* 퍼센티지 기호(%)로 시작해 ASCII 코드로 표현되는 두 개의 16진수 숫자로 이루어진 이스케이프 문자로 바꿈

| 문자 | ASCII 코드 |
|-----|-----------|
| ~ | 126(0x7E) |
| 빈 문자| 32(0x20) |
| % | 37(0x25) |

#### **2.4.3 문자 제한**
* 몇몇 문자는 URL 내에서 특별한 의미로 예약되어 있음
* 아래 표는 URL에서 예약된 문자들을 본래의 목적이 아닌 다른 용도로 사용하려면, 그 전에 반드시 인코딩 해야하는 문자

| 문자 | 선점 및 제한|
|-----|----------|
| % | 인코딩된 문자에 사용할 이스케이프 토큰으로 선점|
| / | 경로 컴포넌트에 있는 경로 세그먼트를 나누는 용도로 선점|
| . | 경로 컴포넌트에서 선점|
| .. | 경로 컴포넌트에서 선점|
| # | 프래그먼트의 구획 문자로 선점|
| ? | 질의 문자열의 구획 문자로 선점|
| ; | 파리미터의 구획 문자로 선점|
| : | 스킴, 사용자 이름/비밀번호, 호스트/포트의 구획 문자로 선점|
| $, + | 선점|
| @ & = | 특정 스킴에서 특별한 의미가 있기 때문에 선점|
| { } | \ ~ [ ] `} | 게이트웨이와 같은 여러 전송 에이전트에서 불안전하게 다루기 때문에 제한|
| < > " | 안전하지 않음|
| 0x00-0x1F, 0x7F | 제한됨, 이 16진수 범위에 속하는 문자는 인쇄되지 않는 US-ASCII 문자|
| > 0x7F | 제한됨, 이 16진수 범위에 속하는 문자는 7비트 US-ASCII 문자가 아님|

### **2.5 스킴의 바다**
* 웹에서 쓰이는 일반 스킴들의 포맷
    * `http` : 하이퍼텍스트 전송 프로토콜 스킴
    * `https` : HTTP 커넥션의 양 끝단에서 암호화하기 위해 넷스케이프에서 개발한 SSL을 사용
    * `mailto` : 이메일 주소를 가리킴
    * `ftp` : 파일 전송 프로토콜은 FTP 서버에서 파일을 내려 받거나 올리고, FTP 서버의 디렉터리에 있는 콘텐츠 목록을 가져오는 데 사용할 수 있다.
    * `rtsp`, `rtspu` : RTSP URL은 실시간 스트리밍 프로토콜을 통해서 읽을 수 있는 오디오 및 비디오와 같은 미디어 리소스 식별자
    * `file` : 주어진 호스트 기기에서 바로 접근할 수 있는 파일을 나타냄
    * `news` : RFC 1036에 정으된 특정 문서나 뉴스 그룹에 접근하는데 사용
    * `telnet` : 대화형 서비스에 접근하는데 사용

## **3장 HTTP 메시지**
* HTTP가 인터넷의 배달원이라면, HTTP 메시지는 소포와 같다.

### **3.1 메시지의 흐름**
* HTTP 메시지*는 HTTP 애플리케이션 간에 주고받은 데이터의 블록

#### **3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다**
* HTTP는 인바운드와 아웃바운드라는 용어를 트랜잭션 방향을 표현하기 위해 사용
* 메시지가 원 서버로 향하는 것은 인바운드
* 메시지가 사용자 에이전트로 돌아오는 것은 아웃바운드

#### **3.1.2 다운스트림으로 흐르는 메시지**
* HTTP의 모든 메시지는 다운스트림으로 흐른다

### **3.2 메시지의 각 부분**
* 메시지는 시작줄, 헤더 블록, 본문으로 나뉨

#### **3.2.1 메시지 문법**
* 요청과 응답 모두 구조가 같음
* 요청 구조
    ```
    <메서드> <요청 URL> <버전>
    <헤더>

    <엔터티 본문>
    ```
* 응답 구조
    ```
    <버전> <상태 코드> <사유 구절>
    <헤더>

    <엔터티 본문>
    ```
* 요청과 응답은 시작줄에서만 문법이 다름

* 메서드 : 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작
* 요청 URL : 요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL의 경로 구성 요소
* 버전 : HTTP의 버전. `HTTP/<메이저>.<마이너>`
* 상태 코드 : 요청 중에 무엇이 일어났는지 설명하는 세자리 숫자
* 사유 구절 : 숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구
* 헤더들 : HTTP 메시지를 설명하는 헤더. 이름, 콜론, 선택적인 공백 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들
* 엔터티 본문 : 임의이 데이터 블록. 모든 메시지가 엔터티 본문을 갖는 것은 아님

#### **3.2.2 시작줄**
* 모든 HTTP 메시지는 시작줄로 시작.
* 요청의 시작줄은 무엇을 해야하는지 말해줌
* 응답의 시작줄은 무슨 일이 일어났는지 말해줌

* 요청줄 : 요청 메시지는 서버에게 리소스에 대해 무언가를 해달라고 부탁
    * 서버에서 어떤 동작이 일어나야 하는지 설명해주는 `메서드`와 그 동작에 대한 대상을 지칭하는 `요청 URL`과 `HTTP 버전` 포함
    * 모든 필드는 공백으로 구분
* 응답줄 : 수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려줌
    * 응답 메시지에서 쓰인 `HTTP의 버전`, 숫자로 된 `상태 코드`, `사유 구절`이 들어 있음
    * 모든 필드는 공백으로 구분
* 메서드 : 서버에게 무엇을 해야하는지 말해줌
    * `GET` : 어떤 문서를 가져옴
    * `HEAD` : 어떤 문서에 대한 헤더만 가져옴
    * `POST` : 처리해야 할 데이터를 보냄. 본문 있음
    * `PUT` : 요청 메시지의 본문을 저장. 본문 있음
    * `TRACE` : 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적
    * `OPTIONS` : 어떤 메서드를 수행할 수 있는지 확인
    * `DELETE` : 서버에서 문서를 제거
* 상태 코드: 클라이언트에게 무슨일이 일어났는지 설명
    * 100~199 : 정보
    * 200~299 : 성공
    * 300~399 : 리다이렉션
    * 400~499 : 클라이언트 에러
    * 500~599 : 서버에러
* 사유 구절: 상태 코드에 대한 글로 된 설명을 제공
* 버전 번호 : HTTP 애플리케이션들이 자신이 따르는 프로토콜의 버전을 상대방에게 알림

#### **3.2.3 헤더**
* 시작줄 다음에는 0개, 1개 혹은 여러개의 HTTP 헤더가 옴
* HTTP 헤더 필드는 요청과 응답 메시지에 추가 정보를 더한다
* 기본적으로 이름/값 쌍의 목록임

* 헤더 분류 : HTTP 헤더 명세는 여러 헤더 필드를 정의. 애플리케이션은 자유롭게 자신만의 헤더를 만들 수도 있음
    * 일반 헤더 : 요청과 응답 양쪽에 나타남
    * 요청 헤더 : 요청에 대한 부가 정보 제공
    * 응답 헤더 : 응답에 대한 부가 정보 제공
    * Entity 헤더 : 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
    * 확장 헤더 : 명세에 정의되지 않은 새로운 헤더

* 헤더를 여러 줄로 나누기
    * 긴 헤더 줄은 읽기 좋게 여러 줄로 쪼갤 수도 있다.
    * 추가 줄 앞에는 최소 하나의 스페이스 혹은 탭 문자가 와야됨
    ```
    HTTP/1.0 200 OK
    Content-Type: image/gif
    Content-Length: 8572
    Server: Test Server
        Version 1.0
    ```

#### **3.2.4 엔터티 본문**
* HTTP 메시지는 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션, 전자우편 등 여러 종류의 디지털 데이터를 엔터티 본문에 실을 수 있다

### **3.3 메서드**
* 모든 서버가 모든 메서드를 구현하지는 않음

#### **3.3.1 안전한 메서드(Safe Method)**
* HTTP는 안전한 메서드라 부리는 메서드의 집합을 정의, ex) `GET`, `HEAD`
* GET이나 HEAD 메서드를 사용하는 HTTP 요청의 결과로 서버에 어떤 일도 일어나지 않음

#### **3.3.2 GET**
* 서버에게 리소스를 달라고 요청하기 위해 쓰임

#### **3.3.3 HEAD**
* GET 처럼 행동하지만, 응답으로 헤더만 돌려줌. 본문은 반환되지 안ㅇㅎ음
    * 리소스를 가져오지 않고도 무엇인지 알 수 있다
    * 상태 코드로 정보를 알 수 있다
    * 리소스가 변경되었는지 검사할 수 있다.


#### **3.3.4 PUT**
* 서버에 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체

#### **3.3.5 POST**
* 서버에 입력 데이터를 전송하기 위해 설계

#### **3.3.6 TRACE**
* 클라이언트가 요청을 보낼 때, 요청은 방화벽, 프락시, 게이트웨이 등의 애플리케이션을 통과함. 이때 HTTP 요청이 수정될 수 있음
* TRACE 메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.
* 요청에 본문을 보낼 수 없음
* 응답의 본문에는 서버가 받은 요청이 그대로 들어있음

#### **3.3.7 OPTIONS**
* 웹 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어봄

#### **3.3.8 DELETE**
* 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청

#### **3.3.9 확장 메서드**
* HTTP는 필요에 따라 확장해도 문제가 없도록 설계


### **3.4 상태 코드**
* 상태 코드는 크게 5가지로 나뉨

#### **3.4.1 100-199 정보성 상태 코드**
* HTTP/1.1에서 도입

* `100 Continue` : 요청의 일부가 받아 들여짐. 클라이언트는 계속 이어서 보냄
* `101 Switcing Protocols` : 클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꿈

#### **3.4.2 200-299** 성공 상태 코드
* `200 OK` : 정상 요청
* `201 Created` : 서버에 개체를 생성하라는 요청에 대한 응답. 리소스에 대한 참조가 담긴 `Locataion` 헤더와 함께 여러 URL을 엔터티 본문에 포함
* `202 Accepted` : 요청은 받아들여졌으니 어떠한 동작도 수행하지 않음. 단지 요청이 받아들이기 적합해 보인다는 의미
* `203 Non-Authoritative Infomation` : 엔터티 헤더에 들어있는 정보가 원래 서버가 아닌 리소스 사본에서 옴
* `204 No Content` : 헤더와 상태줄을 포함하지만 본문을 포함하지 않음
* `205 Reset Content` : 브라우저용 코드. 브라우저에게 현재 페이지에 있는 HTML 폼에 채워진 모든 값을 비우라고 함
* `206 Parital Content` : 범위 요청이 성공, `Content-Range`와 `Date`헤더를 반드시 포함해야 함, `Etag`와 `Content-Location` 중 하나의 헤더도 반드시 포함

#### **3.4.3 300-399** 리다이렉션 상태 코드
* 클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 알려주거나, 그 리소스의 내용 대신 다른 대안 응답을 제공
* 몇몇은 리소스에 대한 애플리케이션의 로컬 복사본이 원래 서버와 비교했을 때 유효한지 확인하기 위해 사용
* 클라이언트가 특정일 이후에 수정한 경우에만 문서를 가져오라고 `If-Modified-Since` 헤더에 담아 전송하면, 문서가 해당 날짜 이후에 변한 것이 없다면, 서버는 콘텐츠 대신 304 상태 코드로 응답
* `300 Multiple Choices` : 클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청한 경우, 해당 리소스의 목록과 함께 반환. 사용자는 목록중 하나를 택할 수 있다.
* `301 Moved Permanently` : 요청한 URL이 옮겨졌을 때 사용. `Location` 헤더에 현재 리소스가 존재하고 있는 URL을 포함
* `302 Found` : `301` 상태 코드와 같음. 하지만 `Location` 헤더로 주어진 URL에 대한 리소스만 임시로 사용. 이후의 요청은 원래 URL 사용
* `303 See Other` : 리소스를 다른 URL에서 가져와야 한다고 알릴 때 사용. 새 URL은 응답 메시지의 Location 헤더에 들어 있음
* `304 Not Modified` : 클라이언트가 GET과 같은 조건부 요청을 보냈고 해당 리소스가 최근에 수정된 일이 없다면, 해당 리소스가 수정되지 않았음을 의미
* `305 Use Proxy` : 리소스가 반드시 프락시를 통해서 접근되어야 함을 알려줌. 프락시의 위치는 Location 헤더를 통해 주어짐
* `306` : 사용 안됨
* `307 Temporary Redirect` : 301 상태 코드와 비슷함. 클라이언트는 Location 헤더로 주어진 URL을 리소스를 임시로 가리키기 위한 목적으로 사용. 이후의 요청에서는 원래 URL을 사용

#### **3.4.4 400-499 클라이언트 에러 상태 코드**
* 클라이언트가 잘못 된 요청을 서버로 보냈을 때 사용하는 코드
* `400 Bad Request` : 클라이언트가 요청을 잘못 보냄
* `401 Unauthorized` : 리소스를 얻기 전에 스스로를 인증하라고 요구
* `402 Payment Required` : 사용 안됨. 미래를 위해 준비
* `403 Forbidden` : 요청이 거부됨.
* `404 Not Found` : 요청한 URL을 찾을 수 없음을 알려줌
* `405 Method Not Allowd` : 지원하지 않는 메소드로 요청을 받았을 때 사용
* `406 Not Acceptable` : 주어진 URL에 대한 리소스 중 클라이언트가 받아들일 수 있는 것이 없는 경우 사용
* `407 Proxy Authentication Required` : 401과 같으나, 리소스에 대해 인증을 요구하는 프락시 서버를 위해 사용
* `408 Request Timeout` : 클라이언트의 요청을 처기하기에 시간이 너무 많이 걸리는 경우, 서버가 요청을 취소하고 해당 코드로 응답
* `409 Conflict` : 요청이 충돌을 일으킬 염려가 있다고 생각될 때 사용
* `410 Gone` : 404와 비슷함. 하지만 서버가 한 때 리소스를 가지고 있었음
* `411 Length Required` : 요청 메시지에 Content-Length가 있어야 할 경우 사용
* `412 Precondition Failed` : 클라이언트가 조건부 요청을 했는데 그중 하나가 실패
* `413 Request Entity Too Large` : 서버가 처리할 수 있는 한계를 넘은 크기의 요청을 보냈을 때
* `414 Not Acceptable` : 요청 URL이 서버가 처리할 수 있는 한계의 길이를 넘었을 때 사용
* `415 Unsuproted Media Type` : 서버가 이해하거나 지원하지 못하는 내용 유형의 엔터티를 클라이언트가 전송했을 때 사용
* `416 Requested Range Not Satisfiable` : 요청이 리소스의 특정 범위를 요청했는데, 범위가 잘못 되었거나 맞지 않을 때 사용
* `417 Not Acceptable` : Expect 요청 헤더에 서버가 만족시킬 수 없는 기대가 담겨있는 경우 사용

#### **3.4.5 500-599 서버 에러 상태 코드**
* 서버 자체에서 발생한 에러
* `500 Internal Server Error` : 서버가 요청을 처리할 수 없게 만드는 에러를 만났을 때 사용
* `501 Not Implemented` : 클라이언트가 서버의 능력을 넘는 요청을 했을 때 사용
* `502 Bad Gateway` : 프락시나 게이트웨이 같은 서버가 해당 요청 응답 연쇄에 있는 다음 링크로부터 가짜 응답에 맞닥뜨렸을 때 사용
* `503 Service Unavailable` : 현재 서버가 요청을 처리 할 수 없을 때 사용. 추후에 가능
* `504 Gateway Timeout` : 408과 비슷하지만, 다른 서버에게 요청을 보내고 응답을 기다리다 타임아웃이 발생한 게이트웨이나 프락시에서 온 응답이라는 점이 다름
* `505 HTTP Version Not Supported` : 서버가 지원할 수 없는 버전의 프로토콜로 된 요청을 받았을 때 사용

### **3.5 헤더**
* 헤더와 메서드는 클라이언트와 서버가 무엇을 하는지 결정하가 위해 함께 사용
* 일반 헤더(General Headers) : 일반 헤더는 클라이언트와 서버 양쪽 모두 사용.
* 요청 헤더(Request Header) : 요청 메시지를 위한 헤더.
* 응답 헤더(Response Header) : 응답 메시지를 위한 헤더
* 엔터티 헤더(Entity Header) : 엔터티 본문에 대한 헤더
* 확장 헤더(Extension Headers) : 개발자들에 의해 만들어졌지만 아직 HTTP 명세에 추가되지 않은 비표준 헤더.

#### **3.5.1 일반 헤더**


